{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyintegrity overview","text":"<p>Pyintegrity is an open-source Python library for processing acoustic well integrity log data, in particular ultrasonic pulse-echo data. With Pyintegrity, you can load well logs that contain the original recorded waveforms and process them using any of the implemented processing algorithms. You can also experiment with these algorithms on real or simulated data, or use Pyintegrity as a framework for developing and testing new algorithms.</p> <p>You can find a more detailed introduction to Pyintegrity in our article Pyintegrity: An Open-Source Toolbox for Processing Ultrasonic Pulse-Echo Well Integrity Log Data, presented at the SPE Norway Subsurface Conference 2024, SPE-218476-MS.</p> <p>Pyintegrity was originally developed by NTNU Researcher Erlend Magnus Viggen (most of the framework, W2/W1 algorithm) and SINTEF Research Scientist Anja Diez (simulation framework, all other algorithms) in a project funded by The Research Council of Norway through the Centre for Innovative Ultrasound Solutions (grant no. 237887).</p> <p>Pyintegrity is made available under an Apache 2.0 license.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>To download and install Pyintegrity in a conda environment named <code>pyintegrity</code>, do the following:</p> <pre><code>git clone https://github.com/erlendviggen/pyintegrity.git\ncd pyintegrity\nconda env create -f environment.yml\nconda activate pyintegrity\npip install -e .\n</code></pre> <p>The included Jupyter Notebook <code>Pyintegrity demo.ipynb</code> provides a demonstration of Pyintegrity by reproducing the results of the article.</p>"},{"location":"#currently-implemented","title":"Currently implemented","text":""},{"location":"#processing-algorithms","title":"Processing algorithms","text":"<p>Pyintegrity currently implements four ultrasonic pulse-echo processing algorithms:</p> <ol> <li>W2/W1 algorithm (Havira 1981)</li> <li>T<sup>3</sup> algorithm (Hayman et al. 1991)</li> <li>ABCD algorithm (Mandal and Standley 2000)</li> <li>L1 algorithm (Tello 2010)<ul> <li>Note that the L1 algorithm is still patented in the USA and Canada. Use the Pyintegrity L1 implementation on your own legal responsibility.</li> </ul> </li> </ol>"},{"location":"#tool-data-extraction","title":"Tool data extraction","text":"<p>Because different logging tools from different vendors store their data in different ways, functions to extract tool data from DLIS files must be tailor-made for each tool. Because of a general lack of public documentation, gaining an understanding about how a new tool's data is structured can require considerable time and effort. Therefore, Pyintegrity currently only has facilities to read log data from tools that the developers have had access to. Currently, Pyintegrity is able to automatically extract data from the log files of:</p> <ol> <li>Ultrasonic Imager Tool (USIT) (including the pulse-echo component of the Isolation Scanner Tool).</li> </ol> <p>Pyintegrity users that have access to and knowledge about other tools' data can write their own code to convert the stored waveform data into Pyintegrity's data structures for processing.</p>"},{"location":"#simulated-data","title":"Simulated data","text":"<p>Pyintegrity facilitates reading simulated measurements from the public dataset Simulated ultrasonic pulse-echo well-integrity dataset by Diez, Viggen, and Johansen.</p>"},{"location":"#pyintegrity-code-principles","title":"Pyintegrity code principles","text":"<ul> <li>Object oriented</li> <li>Type hinted</li> <li>Google-style docstrings</li> <li>Uses the pint (and pint-xarray) library to attach physical units to numbers and arrays</li> <li>Uses the Numba library (and its Rocket-FFT extension) to accelerate performance-critical code</li> <li>Uses the dlisio library for reading log files in the DLIS format</li> </ul>"},{"location":"api-fundamentals/","title":"Fundamentals","text":"<p>These are the fundamental classes and functions used by Pyintegrity.</p>"},{"location":"api-fundamentals/#basic-unit-tools","title":"Basic unit tools","text":"<p>Pyintegrity uses the Pint library's <code>Quantity</code> object to provide numerical values or arrays with physical units. <code>pyintegrity.Quantity</code> should be used instead of <code>pint.Quantity</code>, as the former supports a few additional units that are used in ultrasonic well logs.</p> <p>Similarly to <code>pyintegrity.Quantity</code>, <code>pyintegrity.Unit</code> should be used in place of <code>pint.Unit</code> if necessary. However, it is usually more convenient to use strings to represent units when building <code>Quantity</code> objects.</p>"},{"location":"api-fundamentals/#pyintegrity.Quantity","title":"<code>pyintegrity.Quantity = pint.Quantity</code>  <code>module-attribute</code>","text":""},{"location":"api-fundamentals/#pyintegrity.Unit","title":"<code>pyintegrity.Unit = pint.Unit</code>  <code>module-attribute</code>","text":""},{"location":"api-fundamentals/#pyintegrity.helpers.to_quantity","title":"<code>pyintegrity.helpers.to_quantity(value, target_units=None)</code>","text":"<p>Returns the input value as a pint Quantity with a particular set of units</p> <p>If the input value is a number or an array, it is assumed to already be in the target units, which are applied directly to return a <code>Quantity</code>. If the input value is already a <code>Quantity</code>, the value are converted to the target units. Unlike basic pint unit conversions, this function also supports reciprocal unit conversion, for example when converting from slownesses in e.g. \u00b5s/ft to speeds in e.g. m/s: <code>to_quantity(Quantity(203.2, '\u00b5s/ft'), 'm/s')</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[float, ndarray, Quantity, Parameter, LogChannel]</code> <p>The input value to be assigned the target units</p> required <code>target_units</code> <code>str | Unit | None</code> <p>The target units to be assigned to the input value. <code>None</code> implies no unit conversion.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If an input <code>Quantity</code> cannot be converted to the target units</p> <p>Returns:</p> Type Description <code>Quantity</code> <p>A <code>Quantity</code> object with the target units</p> Source code in <code>src/pyintegrity/helpers.py</code> <pre><code>def to_quantity(value: Union[float, np.ndarray, Quantity, dlis.Parameter, 'LogChannel'], \n                target_units: str | Unit | None = None) -&gt; Quantity:\n    \"\"\"Returns the input value as a pint Quantity with a particular set of units\n\n    If the input value is a number or an array, it is assumed to already be in the target units, which are applied\n    directly to return a `Quantity`. If the input value is already a `Quantity`, the value are converted to the target\n    units. Unlike basic pint unit conversions, this function also supports reciprocal unit conversion, for example when\n    converting from slownesses in e.g. \u00b5s/ft to speeds in e.g. m/s: `to_quantity(Quantity(203.2, '\u00b5s/ft'), 'm/s')`.\n\n    Args:\n        value: The input value to be assigned the target units\n        target_units: The target units to be assigned to the input value. `None` implies no unit conversion.\n\n    Raises:\n        RuntimeError: If an input `Quantity` cannot be converted to the target units\n\n    Returns:\n        A `Quantity` object with the target units\n    \"\"\"\n    from .logchannel import LogChannel  #pylint: disable=import-outside-toplevel; done to avoid a circular import\n\n    if isinstance(value, dlis.Parameter):   # Must convert to a Quantity with the original units\n        number = value.values[0] if len(value.values) == 1 else value.values\n        units = value.attic['VALUES'].units\n        if units:\n            try:\n                value = Quantity(number, units)\n            except ValueError:\n                value = number * Quantity(units)   # To handle units like \"0.1 in\"\n        else:\n            value = Quantity(number)\n    elif isinstance(value, LogChannel):   # Must convert to a Quantity with the original units\n        value = value.array\n\n    if isinstance(value, Quantity):\n        if target_units is None:\n            return value\n        # Convert to the target units, taking the reciprocal if necessary\n        if value.units.is_compatible_with(target_units):\n            return value.to(target_units)   # type: ignore[return-value]\n        if (1/value.units).is_compatible_with(target_units):\n            return (1/value).to(target_units)\n        raise RuntimeError(f'Cannot convert Quantity with units {value.units} to units {target_units}')\n\n    return Quantity(value, target_units)\n</code></pre>"},{"location":"api-fundamentals/#log-information","title":"Log information","text":"<p>In a well log file on the DLIS format, the majority of information is provided as log parameters and log channels. Pyintegrity has internal representations for these types of objects.</p>"},{"location":"api-fundamentals/#pyintegrity.logparameter.LogParameter","title":"<code>pyintegrity.logparameter.LogParameter</code>","text":"<p>Log parameter container class</p> <p>Each <code>LogParameter</code> has a name (aka mnemonic), a description (aka long name), and a set of values. The number of values per parameter is arbitrary; for 0 values, we store <code>None</code>, for 1 value, we store the value itself, and for more values, we store them in an array. Values can have several types, but most are numbers with units (stored as <code>Quantity</code> objects) or strings.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>DLIS parameter to extract data from</p> required <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Name of the log parameter, typically a DLIS mnemonic</p> <code>description</code> <code>str | None</code> <p>Description of the log parameter, typically from a DLIS file</p> <code>values</code> <code>Any | list[Any]</code> <p>The parameter value(s)</p> Source code in <code>src/pyintegrity/logparameter.py</code> <pre><code>class LogParameter:\n    \"\"\"Log parameter container class\n\n    Each `LogParameter` has a name (aka mnemonic), a description (aka long name), and a set of values. The number of\n    values per parameter is arbitrary; for 0 values, we store `None`, for 1 value, we store the value itself, and for\n    more values, we store them in an array. Values can have several types, but most are numbers with units (stored as\n    `Quantity` objects) or strings.\n\n    Args:\n        parameter: DLIS parameter to extract data from\n\n    Attributes:\n        name (str | None): Name of the log parameter, typically a DLIS mnemonic\n        description (str | None): Description of the log parameter, typically from a DLIS file\n        values (Any | list[Any]): The parameter value(s)\n\n    \"\"\"\n    def __init__(self, parameter: dlis.Parameter) -&gt; None:\n        self.name = parameter.name\n        self.description = parameter.long_name\n        if len(parameter.values) == 0:\n            self.values = None\n        elif parameter.values.dtype.kind in ('S', 'U'):   # Parameter values are strings\n            self.values = parameter.values[0] if len(parameter.values) == 1 else parameter.values\n        else:   # Parameter values are numbers, possibly with units\n            self.values = to_quantity(parameter)\n\n    def __repr__(self) -&gt; str:\n        if isinstance(self.values, Quantity):\n            try:\n                return f'{self.name} = {self.values:~P} [{self.description}]'\n            except KeyError:   # Format ~P fails for e.g. units dB/m\n                return f'{self.name} = {self.values:P} [{self.description}]'\n        else:\n            return f'{self.name} = {self.values} [{self.description}]'\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel","title":"<code>pyintegrity.logchannel.LogChannel</code>","text":"<p>Multidimensional log channel data</p> <p>The log channel can have 1-3 dimensions. The first is always depth (<code>z</code>), and the two others can be angle (<code>phi</code>) and either time (<code>t</code>) or frequency (<code>f</code>). The mandatory order is depth-angle-time/frequency. Thus, <code>LogChannel</code> can store depth-only channels (e.g., CBL), depth-angle channels (e.g., outer impedance maps), depth-time channels (e.g., VDL), depth-angle-time channels (e.g., pulse-echo waveforms), and depth-angle-frequency channels (e.g., pulse-echo waveforms frequency spectra).</p> <p>Internally, the log channel is stored as an <code>xarray.DataArray</code>, made unit-aware by the pint-xarray package. Because getting the axes from such <code>DataArray</code> objects is not entirely straightforward, the <code>LogChannel</code> defines properties to get the depth (<code>z</code>), angle (<code>phi</code>), time (<code>t</code>), or frequency (<code>f</code>) axis. The underlying array of the <code>DataArray</code> is always a <code>pint.Quantity</code>, whether the log channel has units or not, and can be accessed through the <code>array</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray | Quantity</code> <p>The underlying array; dimensions must be ordered as depth-angle-time</p> required <code>z</code> <code>ndarray | Quantity</code> <p>The required depth axis of the log channel</p> required <code>phi</code> <code>ndarray | Quantity | None</code> <p>The optional angle axis of the log channel</p> <code>None</code> <code>t</code> <code>ndarray | Quantity | None</code> <p>The optional time axis of the log channel</p> <code>None</code> <code>f</code> <code>ndarray | Quantity | None</code> <p>The optional frequency axis of the log channel</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Name of the log channel, typically a DLIS mnemonic</p> <code>description</code> <code>str | None</code> <p>Description of the log channel, typically from a DLIS file</p> <code>data</code> <code>DataArray</code> <p>The underlying data array as an unit-aware <code>xarray.DataArray</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Issues with the data array dimension order or the data array shape not matching the axes</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>class LogChannel:\n    \"\"\"Multidimensional log channel data\n\n    The log channel can have 1-3 dimensions. The first is always depth (`z`), and the two others can be angle (`phi`)\n    and either time (`t`) or frequency (`f`). The mandatory order is depth-angle-time/frequency. Thus, `LogChannel` can\n    store depth-only channels (e.g., CBL), depth-angle channels (e.g., outer impedance maps), depth-time channels (e.g.,\n    VDL), depth-angle-time channels (e.g., pulse-echo waveforms), and depth-angle-frequency channels (e.g., pulse-echo\n    waveforms frequency spectra).\n\n    Internally, the log channel is stored as an `xarray.DataArray`, made unit-aware by the pint-xarray package. Because\n    getting the axes from such `DataArray` objects is not entirely straightforward, the `LogChannel` defines properties\n    to get the depth (`z`), angle (`phi`), time (`t`), or frequency (`f`) axis. The underlying array of the `DataArray`\n    is always a `pint.Quantity`, whether the log channel has units or not, and can be accessed through the `array`\n    property.\n\n    Args:\n        data: The underlying array; dimensions must be ordered as depth-angle-time\n        z: The required depth axis of the log channel\n        phi: The optional angle axis of the log channel\n        t: The optional time axis of the log channel\n        f: The optional frequency axis of the log channel\n\n    Attributes:\n        name (str | None): Name of the log channel, typically a DLIS mnemonic\n        description (str | None): Description of the log channel, typically from a DLIS file\n        data (xr.DataArray): The underlying data array as an unit-aware `xarray.DataArray`\n\n    Raises:\n        ValueError: Issues with the data array dimension order or the data array shape not matching the axes\n    \"\"\"\n    def __init__(self,\n                 data: np.ndarray | Quantity,\n                 z: np.ndarray | Quantity,\n                 phi: np.ndarray | Quantity | None = None,\n                 t: np.ndarray | Quantity | None = None,\n                 f: np.ndarray | Quantity | None = None,\n                 name: str | None = None,\n                 description: str | None = None) -&gt; None:\n        self.name = name\n        self.description = description\n\n        if t is not None and f is not None:\n            raise ValueError('LogChannel got both time and frequency axes')\n\n        # Ensure that the axes have the correct units\n        z = to_quantity(np.atleast_1d(z), 'm')\n        if phi is not None and not isinstance(phi, Quantity):\n            phi = to_quantity(np.atleast_1d(phi), 'deg')\n        if t is not None and not isinstance(t, Quantity):\n            t = to_quantity(np.atleast_1d(t), 's')\n        if f is not None and not isinstance(f, Quantity):\n            f = to_quantity(np.atleast_1d(f), 'Hz')\n\n        # Ensure that the data array has the right size\n        n_axes = (z is not None) + (phi is not None) + (t is not None) + (f is not None)\n        if n_axes &lt; data.ndim:\n            raise ValueError(f'LogChannel got a {data.ndim}-dimensional data array but only {n_axes} axes')\n        data = self._array_to_nd(np.atleast_1d(data), target_ndim=n_axes)\n\n        # Ensure that the data array is ordered as depth, angle, time/frequency\n        i_dim = 0\n        for axis in (z, phi, t, f):\n            if axis is None:\n                continue\n            if data.shape[i_dim] == len(axis):\n                i_dim += 1\n                continue\n            raise ValueError(f'data shape {data.shape} does not match input axes in depth-angle-time/freq order')\n        if i_dim != data.ndim:\n            raise ValueError(f'data shape {data.shape} does not match input axes in depth-angle-time/freq order')\n\n        # Build DataArray\n        coords: dict[str, Quantity] = {name: ax for name, ax in [('z', z), ('phi', phi), ('t', t), ('f', f)]\n                                       if ax is not None}\n        data_unitless = xr.DataArray(Quantity(data), coords={name: ax.magnitude for name, ax in coords.items()})\n        data_unitless = self._ensure_increasing_coords(data_unitless)\n        self.data: xr.DataArray = data_unitless.pint.quantify({name: ax.units for name, ax in coords.items()})\n\n    @property\n    def z(self) -&gt; Quantity:\n        \"\"\"Get depth axis as a Quantity\"\"\"\n        return Quantity(self.data.z.to_numpy(), self.data.z.attrs['units'])\n\n    @property\n    def phi(self) -&gt; Quantity | None:\n        \"\"\"Get angle axis as a Quantity, if it exists\"\"\"\n        if 'phi' not in self.data.coords:\n            return None\n        return Quantity(self.data.phi.to_numpy(), self.data.phi.attrs['units'])\n\n    @property\n    def t(self) -&gt; Quantity | None:\n        \"\"\"Get time axis as a Quantity, if it exists\"\"\"\n        if 't' not in self.data.coords:\n            return None\n        return Quantity(self.data.t.to_numpy(), self.data.t.attrs['units'])\n\n    @property\n    def f(self) -&gt; Quantity | None:\n        \"\"\"Get frequency axis as a Quantity, if it exists\"\"\"\n        if 'f' not in self.data.coords:\n            return None\n        return Quantity(self.data.f.to_numpy(), self.data.f.attrs['units'])\n\n    @property\n    def array(self) -&gt; Quantity:\n        \"\"\"Get the underlying data array\"\"\"\n        return self.data.data\n\n    def to(self, units: str | Unit) -&gt; Self:\n        \"\"\"Convert channel units\n\n        Args:\n            units: Compatible units to convert to\n        \"\"\"\n        out = self.copy()\n        out.data = out.data.pint.to(units)\n        return out\n\n    def to_numpy(self) -&gt; np.ndarray:\n        \"\"\"Get the underlying data array as a unitless numpy array\"\"\"\n        return self.data.to_numpy()\n\n    def interpolate_to(self,\n                       z: Quantity | None = None,\n                       phi: Quantity | None = None,\n                       t: Quantity | None = None,\n                       f: Quantity | None = None,\n                       extrapolate: bool = True,\n                       method: str = 'linear') -&gt; Self:\n        \"\"\"Interpolate the log channel to a new set of axes\n\n        Args:\n            z: Optional new depth axis to interpolate to\n            phi: Optional new angle axis to interpolate to\n            t: Optional new time axis to interpolate to\n            f: Optional new frequency axis to interpolate to\n            extrapolate: When going outside the original axes, whether to fill by edge values (`True`) or NaNs (`False`)\n            method: Interpolation method to use\n\n        Returns:\n            A new LogChannel with the interpolated data\n        \"\"\"\n        kwargs: dict[str, Any] = {'fill_value': 'extrapolate'} if extrapolate else {'fill_value': np.nan}\n        coords = {name: ax for name, ax in [('z', z), ('phi', phi), ('t', t), ('f', f)] if ax is not None}\n\n        new = copy.copy(self)\n        new.data = new.data.pint.interp(coords, method=method, kwargs=kwargs)\n        return new\n\n    def plot_in(self,\n                ax: plt.Axes,\n                z: Quantity | None = None,\n                phi: Quantity | None = None,\n                t: Quantity | None = None,\n                f: Quantity | None = None,\n                method: str = 'nearest',\n                **kwargs) -&gt; plt.Axes:\n        \"\"\"Plot log channel data\n\n        The arguments `z`, `phi`, `t`, and `f` can be used to reduce the dimensionality of the data before plotting or\n        to select a subset for plotting.\n\n        Args:\n            ax: matplotlib `Axes` to plot into\n            z: Optional depths to select before plotting\n            phi: Optional angles to select before plotting\n            t: Optional times to select before plotting\n            f: Optional frequencies to select before plotting\n            method: Selection method\n\n        Returns:\n            Whatever `xarray.DataArray.plot` returns\n        \"\"\"\n        coords = {name: ax for name, ax in [('z', z), ('phi', phi), ('t', t), ('f', f)] if ax is not None}\n        data: xr.DataArray = self.data.pint.sel(coords, method=method)\n\n        # Specify some reasonable plot defaults\n        if 'z' in data.coords.keys() and data.coords['z'].size &gt; 1:   # The data is indexed by depth\n            if 'yincrease' not in kwargs:\n                kwargs['yincrease'] = False   # Make sure depth increases downwards\n            if len(data.coords) == 1 and 'y' not in kwargs:\n                kwargs['y'] = 'z'   # 1D line plot; make sure depth is on the y axis\n\n        return data.plot(ax=ax, **kwargs)\n\n    def copy(self) -&gt; Self:\n        \"\"\"Make a shallow copy of the object with a deep copy of the data array\"\"\"\n        new = copy.copy(self)\n        new.data = self.data.copy()\n        return new\n\n    def get_depth_section(self, top: float, bottom: float) -&gt; Self:\n        \"\"\"Return a copy which only contains data in the specified interval of the depth axis\n\n        Args:\n            top: Start of depth interval, in m\n            bottom: End of depth interval, in m\n\n        Returns:\n            A copy of this `LogChannel` containing only an interval of the original depth axis\n        \"\"\"\n        channel = self.copy()\n        channel.data = channel.data.sel(z=slice(top, bottom))\n        return channel\n\n    def equalize_by_percentiles(self,\n                              reference: 'LogChannel',\n                              percentiles: tuple[float, float] = (25, 75)) -&gt; Self:\n        \"\"\"Return a copy which has been equalized with a reference according to the values at the specified percentiles\n\n        Args:\n            reference: Reference `LogChannel` to equalize with\n            percentiles: Percentiles to equalize values at\n\n        Returns:\n            A new and equalized `LogChannel`\n        \"\"\"\n        assert len(percentiles) == 2\n        values_ref = np.nanpercentile(reference.array, percentiles)\n        values_self = np.nanpercentile(self.array, percentiles)\n\n        out_array = self.array - values_self[0]\n        out_array = out_array / (values_self[1] - values_self[0]) * (values_ref[1] - values_ref[0])\n        out_array = out_array + values_ref[0]\n\n        out_channel = self.copy()\n        out_channel.data.data = out_array\n        return out_channel\n\n    @staticmethod\n    def _array_to_nd(array: np.ndarray | Quantity, target_ndim: int) -&gt; np.ndarray | Quantity:\n        \"\"\"Return array with new dimensions filled in from the start if necessary\"\"\"\n        if array.ndim &gt; target_ndim:\n            raise ValueError(f'Got a {array.ndim}-dimensional data array with a target of {target_ndim} dimensions')\n        while array.ndim &lt; target_ndim:\n            array = array[np.newaxis, :]\n        return array\n\n    @staticmethod\n    def _ensure_increasing_coords(data: xr.DataArray) -&gt; xr.DataArray:\n        \"\"\"Ensure that the axes are all in increasing order, to avoid later problems with slicing order\"\"\"\n        for coord_name, coord in data.coords.items():\n            if len(coord.data) == 1:   # Coordinate is just one point\n                continue \n            if coord.data[1] &lt; coord.data[0]:   # Coordinate axis is in decreasing order (assuming monotonic coords)\n                data = data.isel({coord_name: slice(None, None, -1)})   # Reverse coordinates to get increasing order\n        return data\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.array","title":"<code>array: Quantity</code>  <code>property</code>","text":"<p>Get the underlying data array</p>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.f","title":"<code>f: Quantity | None</code>  <code>property</code>","text":"<p>Get frequency axis as a Quantity, if it exists</p>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.phi","title":"<code>phi: Quantity | None</code>  <code>property</code>","text":"<p>Get angle axis as a Quantity, if it exists</p>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.t","title":"<code>t: Quantity | None</code>  <code>property</code>","text":"<p>Get time axis as a Quantity, if it exists</p>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.z","title":"<code>z: Quantity</code>  <code>property</code>","text":"<p>Get depth axis as a Quantity</p>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.copy","title":"<code>copy()</code>","text":"<p>Make a shallow copy of the object with a deep copy of the data array</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Make a shallow copy of the object with a deep copy of the data array\"\"\"\n    new = copy.copy(self)\n    new.data = self.data.copy()\n    return new\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.equalize_by_percentiles","title":"<code>equalize_by_percentiles(reference, percentiles=(25, 75))</code>","text":"<p>Return a copy which has been equalized with a reference according to the values at the specified percentiles</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>LogChannel</code> <p>Reference <code>LogChannel</code> to equalize with</p> required <code>percentiles</code> <code>tuple[float, float]</code> <p>Percentiles to equalize values at</p> <code>(25, 75)</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new and equalized <code>LogChannel</code></p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def equalize_by_percentiles(self,\n                          reference: 'LogChannel',\n                          percentiles: tuple[float, float] = (25, 75)) -&gt; Self:\n    \"\"\"Return a copy which has been equalized with a reference according to the values at the specified percentiles\n\n    Args:\n        reference: Reference `LogChannel` to equalize with\n        percentiles: Percentiles to equalize values at\n\n    Returns:\n        A new and equalized `LogChannel`\n    \"\"\"\n    assert len(percentiles) == 2\n    values_ref = np.nanpercentile(reference.array, percentiles)\n    values_self = np.nanpercentile(self.array, percentiles)\n\n    out_array = self.array - values_self[0]\n    out_array = out_array / (values_self[1] - values_self[0]) * (values_ref[1] - values_ref[0])\n    out_array = out_array + values_ref[0]\n\n    out_channel = self.copy()\n    out_channel.data.data = out_array\n    return out_channel\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.get_depth_section","title":"<code>get_depth_section(top, bottom)</code>","text":"<p>Return a copy which only contains data in the specified interval of the depth axis</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>float</code> <p>Start of depth interval, in m</p> required <code>bottom</code> <code>float</code> <p>End of depth interval, in m</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A copy of this <code>LogChannel</code> containing only an interval of the original depth axis</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def get_depth_section(self, top: float, bottom: float) -&gt; Self:\n    \"\"\"Return a copy which only contains data in the specified interval of the depth axis\n\n    Args:\n        top: Start of depth interval, in m\n        bottom: End of depth interval, in m\n\n    Returns:\n        A copy of this `LogChannel` containing only an interval of the original depth axis\n    \"\"\"\n    channel = self.copy()\n    channel.data = channel.data.sel(z=slice(top, bottom))\n    return channel\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.interpolate_to","title":"<code>interpolate_to(z=None, phi=None, t=None, f=None, extrapolate=True, method='linear')</code>","text":"<p>Interpolate the log channel to a new set of axes</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Quantity | None</code> <p>Optional new depth axis to interpolate to</p> <code>None</code> <code>phi</code> <code>Quantity | None</code> <p>Optional new angle axis to interpolate to</p> <code>None</code> <code>t</code> <code>Quantity | None</code> <p>Optional new time axis to interpolate to</p> <code>None</code> <code>f</code> <code>Quantity | None</code> <p>Optional new frequency axis to interpolate to</p> <code>None</code> <code>extrapolate</code> <code>bool</code> <p>When going outside the original axes, whether to fill by edge values (<code>True</code>) or NaNs (<code>False</code>)</p> <code>True</code> <code>method</code> <code>str</code> <p>Interpolation method to use</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new LogChannel with the interpolated data</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def interpolate_to(self,\n                   z: Quantity | None = None,\n                   phi: Quantity | None = None,\n                   t: Quantity | None = None,\n                   f: Quantity | None = None,\n                   extrapolate: bool = True,\n                   method: str = 'linear') -&gt; Self:\n    \"\"\"Interpolate the log channel to a new set of axes\n\n    Args:\n        z: Optional new depth axis to interpolate to\n        phi: Optional new angle axis to interpolate to\n        t: Optional new time axis to interpolate to\n        f: Optional new frequency axis to interpolate to\n        extrapolate: When going outside the original axes, whether to fill by edge values (`True`) or NaNs (`False`)\n        method: Interpolation method to use\n\n    Returns:\n        A new LogChannel with the interpolated data\n    \"\"\"\n    kwargs: dict[str, Any] = {'fill_value': 'extrapolate'} if extrapolate else {'fill_value': np.nan}\n    coords = {name: ax for name, ax in [('z', z), ('phi', phi), ('t', t), ('f', f)] if ax is not None}\n\n    new = copy.copy(self)\n    new.data = new.data.pint.interp(coords, method=method, kwargs=kwargs)\n    return new\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.plot_in","title":"<code>plot_in(ax, z=None, phi=None, t=None, f=None, method='nearest', **kwargs)</code>","text":"<p>Plot log channel data</p> <p>The arguments <code>z</code>, <code>phi</code>, <code>t</code>, and <code>f</code> can be used to reduce the dimensionality of the data before plotting or to select a subset for plotting.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>matplotlib <code>Axes</code> to plot into</p> required <code>z</code> <code>Quantity | None</code> <p>Optional depths to select before plotting</p> <code>None</code> <code>phi</code> <code>Quantity | None</code> <p>Optional angles to select before plotting</p> <code>None</code> <code>t</code> <code>Quantity | None</code> <p>Optional times to select before plotting</p> <code>None</code> <code>f</code> <code>Quantity | None</code> <p>Optional frequencies to select before plotting</p> <code>None</code> <code>method</code> <code>str</code> <p>Selection method</p> <code>'nearest'</code> <p>Returns:</p> Type Description <code>Axes</code> <p>Whatever <code>xarray.DataArray.plot</code> returns</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def plot_in(self,\n            ax: plt.Axes,\n            z: Quantity | None = None,\n            phi: Quantity | None = None,\n            t: Quantity | None = None,\n            f: Quantity | None = None,\n            method: str = 'nearest',\n            **kwargs) -&gt; plt.Axes:\n    \"\"\"Plot log channel data\n\n    The arguments `z`, `phi`, `t`, and `f` can be used to reduce the dimensionality of the data before plotting or\n    to select a subset for plotting.\n\n    Args:\n        ax: matplotlib `Axes` to plot into\n        z: Optional depths to select before plotting\n        phi: Optional angles to select before plotting\n        t: Optional times to select before plotting\n        f: Optional frequencies to select before plotting\n        method: Selection method\n\n    Returns:\n        Whatever `xarray.DataArray.plot` returns\n    \"\"\"\n    coords = {name: ax for name, ax in [('z', z), ('phi', phi), ('t', t), ('f', f)] if ax is not None}\n    data: xr.DataArray = self.data.pint.sel(coords, method=method)\n\n    # Specify some reasonable plot defaults\n    if 'z' in data.coords.keys() and data.coords['z'].size &gt; 1:   # The data is indexed by depth\n        if 'yincrease' not in kwargs:\n            kwargs['yincrease'] = False   # Make sure depth increases downwards\n        if len(data.coords) == 1 and 'y' not in kwargs:\n            kwargs['y'] = 'z'   # 1D line plot; make sure depth is on the y axis\n\n    return data.plot(ax=ax, **kwargs)\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.to","title":"<code>to(units)</code>","text":"<p>Convert channel units</p> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>str | Unit</code> <p>Compatible units to convert to</p> required Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def to(self, units: str | Unit) -&gt; Self:\n    \"\"\"Convert channel units\n\n    Args:\n        units: Compatible units to convert to\n    \"\"\"\n    out = self.copy()\n    out.data = out.data.pint.to(units)\n    return out\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.logchannel.LogChannel.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Get the underlying data array as a unitless numpy array</p> Source code in <code>src/pyintegrity/logchannel.py</code> <pre><code>def to_numpy(self) -&gt; np.ndarray:\n    \"\"\"Get the underlying data array as a unitless numpy array\"\"\"\n    return self.data.to_numpy()\n</code></pre>"},{"location":"api-fundamentals/#containers","title":"Containers","text":"<p>These container classes are used for well-related information.</p>"},{"location":"api-fundamentals/#pyintegrity.material.Material","title":"<code>pyintegrity.material.Material</code>","text":"<p>Contains information on the parameters of a material</p> <p>1-3 material parameters may be provided. If 2 are provided, the 3rd parameter can be calculated.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float | ndarray | Quantity | LogChannel | None</code> <p>P-wave speed of the material</p> <code>None</code> <code>impedance</code> <code>float | ndarray | Quantity | LogChannel | None</code> <p>P-wave impedance of the material</p> <code>None</code> <code>density</code> <code>float | ndarray | Quantity | LogChannel | None</code> <p>Mass density of the material</p> <code>None</code> Source code in <code>src/pyintegrity/material.py</code> <pre><code>class Material:\n    \"\"\"Contains information on the parameters of a material\n\n    1-3 material parameters may be provided. If 2 are provided, the 3rd parameter can be calculated.\n\n    Args:\n        speed: P-wave speed of the material\n        impedance: P-wave impedance of the material\n        density: Mass density of the material\n    \"\"\"\n    def __init__(self,\n                 speed: float | np.ndarray | Quantity | LogChannel | None = None,\n                 impedance: float | np.ndarray | Quantity | LogChannel | None = None,\n                 density: float | np.ndarray | Quantity | LogChannel | None = None) -&gt; None:\n        if speed is not None:\n            speed = to_quantity(speed, 'm/s')\n        self._speed = speed\n        if impedance is not None:\n            impedance = to_quantity(impedance, 'MRayl')\n        self._impedance = impedance\n        if density is not None:\n            density = to_quantity(density, 'kg/m^3')\n        self._density = density\n\n    @property\n    def speed(self) -&gt; Quantity | None:\n        \"\"\"Get the P-wave speed in m/s, calculating if necessary\"\"\"\n        if self._speed is not None:\n            return self._speed\n        if self._impedance is not None and self._density is not None:\n            speed = self._impedance / self._density\n            return speed.to('m/s')\n        return None\n\n    @property\n    def impedance(self) -&gt; Quantity | None:\n        \"\"\"Get the P-wave impedance in MRayl, calculating if necessary\"\"\"\n        if self._impedance is not None:\n            return self._impedance\n        if self._speed is not None and self._density is not None:\n            impedance = self._speed * self._density\n            return impedance.to('MRayl')\n        return None\n\n    @property\n    def density(self) -&gt; Quantity | None:\n        \"\"\"Get the density in kg/m^3, calculating if necessary\"\"\"\n        if self._density is not None:\n            return self._density\n        if self._speed is not None and self._impedance is not None:\n            density = self._impedance / self._speed\n            return density.to('kg/m^3')\n        return None\n\n    def get_depth_section(self, i_start: int, i_end: int) -&gt; 'Material':\n        \"\"\"Return a `Material` copy which only contains data in the specified range\n\n        Args:\n            i_start: Start index of the range\n            i_end: End index of the range\n\n        Returns:\n            A new `Material` containing the data in the specified range\n        \"\"\"\n        speed = None if self._speed is None else self._speed[i_start:i_end]\n        impedance = None if self._impedance is None else self._impedance[i_start:i_end]\n        density = None if self._density is None else self._density[i_start:i_end]\n        return Material(speed=speed, impedance=impedance, density=density)\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.material.Material.density","title":"<code>density: Quantity | None</code>  <code>property</code>","text":"<p>Get the density in kg/m^3, calculating if necessary</p>"},{"location":"api-fundamentals/#pyintegrity.material.Material.impedance","title":"<code>impedance: Quantity | None</code>  <code>property</code>","text":"<p>Get the P-wave impedance in MRayl, calculating if necessary</p>"},{"location":"api-fundamentals/#pyintegrity.material.Material.speed","title":"<code>speed: Quantity | None</code>  <code>property</code>","text":"<p>Get the P-wave speed in m/s, calculating if necessary</p>"},{"location":"api-fundamentals/#pyintegrity.material.Material.get_depth_section","title":"<code>get_depth_section(i_start, i_end)</code>","text":"<p>Return a <code>Material</code> copy which only contains data in the specified range</p> <p>Parameters:</p> Name Type Description Default <code>i_start</code> <code>int</code> <p>Start index of the range</p> required <code>i_end</code> <code>int</code> <p>End index of the range</p> required <p>Returns:</p> Type Description <code>Material</code> <p>A new <code>Material</code> containing the data in the specified range</p> Source code in <code>src/pyintegrity/material.py</code> <pre><code>def get_depth_section(self, i_start: int, i_end: int) -&gt; 'Material':\n    \"\"\"Return a `Material` copy which only contains data in the specified range\n\n    Args:\n        i_start: Start index of the range\n        i_end: End index of the range\n\n    Returns:\n        A new `Material` containing the data in the specified range\n    \"\"\"\n    speed = None if self._speed is None else self._speed[i_start:i_end]\n    impedance = None if self._impedance is None else self._impedance[i_start:i_end]\n    density = None if self._density is None else self._density[i_start:i_end]\n    return Material(speed=speed, impedance=impedance, density=density)\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.casing.Casing","title":"<code>pyintegrity.casing.Casing</code>","text":"<p>Contains information on a casing</p> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>Material | None</code> <p>A <code>Material</code> object specifying the casing's material</p> <code>None</code> <code>outer_radius_nominal</code> <code>Quantity | None</code> <p>A <code>Quantity</code> object with length units describing the nominal outer radius</p> <code>None</code> <code>thickness_nominal</code> <code>Quantity | None</code> <p>A <code>Quantity</code> object with length units describing the nominal casing thickness</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>material</code> <code>Material | None</code> <p>The casing material</p> <code>outer_radius_nominal</code> <code>Quantity | None</code> <p>The outer radius of the casing</p> <code>thickness_nominal</code> <code>Quantity | None</code> <p>The casing thickness</p> Source code in <code>src/pyintegrity/casing.py</code> <pre><code>class Casing:\n    \"\"\"Contains information on a casing\n\n    Args:\n        material: A `Material` object specifying the casing's material\n        outer_radius_nominal: A `Quantity` object with length units describing the nominal outer radius\n        thickness_nominal: A `Quantity` object with length units describing the nominal casing thickness\n\n    Attributes:\n        material (Material | None): The casing material\n        outer_radius_nominal (Quantity | None): The outer radius of the casing\n        thickness_nominal (Quantity | None): The casing thickness\n    \"\"\"\n    def __init__(self,\n                 material: Material | None = None,\n                 outer_radius_nominal: Quantity | None = None,\n                 thickness_nominal: Quantity | None = None) -&gt; None:\n        self.material = material\n        self.outer_radius_nominal = outer_radius_nominal\n        self.thickness_nominal = thickness_nominal\n\n    @property\n    def outer_diameter_nominal(self) -&gt; Quantity | None:\n        \"\"\"Returns nominal outer diameter\"\"\"\n        if self.outer_radius_nominal is None:\n            return None\n        return 2 * self.outer_radius_nominal\n\n    @property\n    def inner_radius_nominal(self) -&gt; Quantity | None:\n        \"\"\"Returns nominal inner radius\"\"\"\n        if self.outer_radius_nominal is None or self.thickness_nominal is None:\n            return None\n        return self.outer_radius_nominal - self.thickness_nominal\n\n    @property\n    def inner_diameter_nominal(self) -&gt; Quantity | None:\n        \"\"\"Returns nominal inner diameter\"\"\"\n        if self.inner_radius_nominal is None:\n            return None\n        return self.inner_radius_nominal * 2\n</code></pre>"},{"location":"api-fundamentals/#pyintegrity.casing.Casing.inner_diameter_nominal","title":"<code>inner_diameter_nominal: Quantity | None</code>  <code>property</code>","text":"<p>Returns nominal inner diameter</p>"},{"location":"api-fundamentals/#pyintegrity.casing.Casing.inner_radius_nominal","title":"<code>inner_radius_nominal: Quantity | None</code>  <code>property</code>","text":"<p>Returns nominal inner radius</p>"},{"location":"api-fundamentals/#pyintegrity.casing.Casing.outer_diameter_nominal","title":"<code>outer_diameter_nominal: Quantity | None</code>  <code>property</code>","text":"<p>Returns nominal outer diameter</p>"},{"location":"api-pulseecho-data/","title":"Pulse-echo data","text":"<p>Because different logging tools from different vendors store their data in different ways, functions to extract tool data from DLIS files must be tailor-made for each tool. Pyintegrity then represents a pulse-echo measurement series, with all the measured waveforms, as a <code>PulseEchoSeries</code> object.</p>"},{"location":"api-pulseecho-data/#pulse-echo-measurements","title":"Pulse-echo measurements","text":""},{"location":"api-pulseecho-data/#pyintegrity.pulseecho.series.PulseEchoSeries","title":"<code>pyintegrity.pulseecho.series.PulseEchoSeries</code>","text":"<p>             Bases: <code>LogChannel</code></p> <p>Contains ultrasonic pulse-echo waveform data and supplementary information about the inner fluid and casing</p> <p><code>PulseEchoSeries</code> objects are intended as the input for the implemented pulse-echo processing algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>ndarray | Quantity</code> <p>1D-3D array of ultrasonic pulse-echo waveforms, with dimensions in depth-angle-time order</p> required <code>sampling_freq</code> <code>float | Quantity</code> <p>Sampling frequency. Must be provided in seconds or as a <code>Quantity</code> object with time units.</p> required <code>z</code> <code>ndarray | Quantity</code> <p>Depth axis of the waveform array</p> required <code>phi</code> <code>ndarray | Quantity | None</code> <p>Angle axis of the waveform array</p> <code>None</code> <code>t_0</code> <code>ndarray | Quantity | None</code> <p>Time of the first sample for every waveform in the waveform array</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>sampling_freq</code> <code>Quantity</code> <p>Waveform sampling frequency</p> <code>casing</code> <code>Casing | None</code> <p>Casing information</p> <code>inner_material</code> <code>Material | None</code> <p>Material on the inner fluid</p> Source code in <code>src/pyintegrity/pulseecho/series.py</code> <pre><code>class PulseEchoSeries(LogChannel):\n    \"\"\"Contains ultrasonic pulse-echo waveform data and supplementary information about the inner fluid and casing\n\n    `PulseEchoSeries` objects are intended as the input for the implemented pulse-echo processing algorithms.\n\n    Args:\n        waveforms: 1D-3D array of ultrasonic pulse-echo waveforms, with dimensions in depth-angle-time order\n        sampling_freq: Sampling frequency. Must be provided in seconds or as a `Quantity` object with time units.\n        z: Depth axis of the waveform array\n        phi: Angle axis of the waveform array\n        t_0: Time of the first sample for every waveform in the waveform array\n\n    Attributes:\n        sampling_freq (Quantity): Waveform sampling frequency\n        casing (Casing | None): Casing information\n        inner_material (Material | None): Material on the inner fluid\n    \"\"\"\n    def __init__(self,\n                 waveforms: np.ndarray | Quantity,\n                 sampling_freq: float | Quantity,\n                 z: np.ndarray | Quantity,\n                 phi: np.ndarray | Quantity | None = None,\n                 t_0: np.ndarray | Quantity | None = None) -&gt; None:\n        self.sampling_freq = to_quantity(sampling_freq, 'Hz')\n        z, phi, t = self._conform_axes(waveforms, z, phi)\n\n        # Store data\n        super().__init__(data=waveforms, z=z, phi=phi, t=t)\n\n        # Store waveform time axes\n        self.t_abs: xr.DataArray | None\n        if t_0 is not None:\n            t_0 = LogChannel._array_to_nd(t_0, 2)\n            if not t_0.shape[0] == waveforms.shape[0] and t_0.shape[1] == waveforms.shape[1]:\n                raise ValueError('PESeries constructor got arrays for waveforms and start times that do not match')\n            t_0 = to_quantity(t_0, 's')\n            t_abs = t_0[:, :, np.newaxis] + t[np.newaxis, np.newaxis, :]\n            self.t_abs = LogChannel(t_abs, z=z, phi=phi, t=t).data\n        else:\n            self.t_abs = None\n\n        self.casing: Casing | None = None\n        self.inner_material: Material | None = None\n\n    @property\n    def sampling_period(self):\n        \"\"\"Returns sampling period as the inverse of the sampling frequency\"\"\"\n        return (1 / self.sampling_freq).to('s')\n\n    def get_depth_section(self, top: float, bottom: float) -&gt; Self:\n        \"\"\"Return a copy which only contains data in the specified interval of the depth axis\n\n        Args:\n            top: Start of depth interval, in m\n            bottom: End of depth interval, in m\n\n        Returns:\n            A copy of this `PulseEchoSeries` containing only an interval of the original depth axis\n        \"\"\"\n        i_top = list(self.data.z.values).index(self.data.sel(z=top, method='bfill').z)\n        i_bot = list(self.data.z.values).index(self.data.sel(z=bottom, method='ffill').z)\n\n        series = self.copy()\n        series.data = series.data.isel(z=slice(i_top, i_bot+1))\n        if series.inner_material is not None:\n            series.inner_material = series.inner_material.get_depth_section(i_top, i_bot+1)\n\n        return series\n\n\n    def _conform_axes(self, data, depths, angles) -&gt; tuple[Quantity, Quantity, Quantity]:\n        \"\"\"Returns conformed depth, angle, and time axes as `Quantity` objects with the desired units\"\"\"\n        depths = to_quantity(depths, 'm')\n        if angles is None:\n            angles = 360 * np.linspace(0, 1, data.shape[1], endpoint=False)\n        angles = to_quantity(angles, 'deg')\n        sampling_period = self.sampling_period\n        times = Quantity(self.sampling_period * np.arange(data.shape[2]), sampling_period.units)\n        return depths, angles, times\n\n    def _get_absolute_time_axes(self, waveforms, start_times) -&gt; xr.DataArray | None:\n        if start_times is not None and self.t is not None:\n            start_times = LogChannel._array_to_nd(start_times, 2)\n            if not start_times.shape[0] == waveforms.shape[0] and start_times.shape[1] == waveforms.shape[1]:\n                raise ValueError('PESeries constructor got arrays for waveforms and start times that do not match')\n            start_times = to_quantity(start_times, 's')\n            t_abs = start_times[:, :, np.newaxis] + self.t[np.newaxis, np.newaxis, :]\n            t_abs = LogChannel(t_abs, z=self.z, phi=self.phi, t=self.t).data\n        else:\n            t_abs = None\n        return t_abs\n</code></pre>"},{"location":"api-pulseecho-data/#pyintegrity.pulseecho.series.PulseEchoSeries.sampling_period","title":"<code>sampling_period</code>  <code>property</code>","text":"<p>Returns sampling period as the inverse of the sampling frequency</p>"},{"location":"api-pulseecho-data/#pyintegrity.pulseecho.series.PulseEchoSeries.get_depth_section","title":"<code>get_depth_section(top, bottom)</code>","text":"<p>Return a copy which only contains data in the specified interval of the depth axis</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>float</code> <p>Start of depth interval, in m</p> required <code>bottom</code> <code>float</code> <p>End of depth interval, in m</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A copy of this <code>PulseEchoSeries</code> containing only an interval of the original depth axis</p> Source code in <code>src/pyintegrity/pulseecho/series.py</code> <pre><code>def get_depth_section(self, top: float, bottom: float) -&gt; Self:\n    \"\"\"Return a copy which only contains data in the specified interval of the depth axis\n\n    Args:\n        top: Start of depth interval, in m\n        bottom: End of depth interval, in m\n\n    Returns:\n        A copy of this `PulseEchoSeries` containing only an interval of the original depth axis\n    \"\"\"\n    i_top = list(self.data.z.values).index(self.data.sel(z=top, method='bfill').z)\n    i_bot = list(self.data.z.values).index(self.data.sel(z=bottom, method='ffill').z)\n\n    series = self.copy()\n    series.data = series.data.isel(z=slice(i_top, i_bot+1))\n    if series.inner_material is not None:\n        series.inner_material = series.inner_material.get_depth_section(i_top, i_bot+1)\n\n    return series\n</code></pre>"},{"location":"api-pulseecho-data/#usit-data-extraction","title":"USIT data extraction","text":""},{"location":"api-pulseecho-data/#pyintegrity.pulseecho.usit.get_usit_data","title":"<code>pyintegrity.pulseecho.usit.get_usit_data(file)</code>","text":"<p>Get all USIT-specific channels and parameters from a DLIS logical file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>LogicalFile</code> <p>The DLIS logical file to extract data from</p> required <p>Returns:</p> Type Description <code>tuple[dict[FrameName, dict[ChannelName, LogChannel]], dict[ParameterName, LogParameter]]</code> <p>USIT channels as <code>LogChannel</code> objects, organized by frame in a dict, and USIT parameters in a dict</p> Source code in <code>src/pyintegrity/pulseecho/usit.py</code> <pre><code>def get_usit_data(file: dlis.LogicalFile) -&gt; tuple[dict[FrameName, dict[ChannelName, LogChannel]],\n                                                   dict[ParameterName, LogParameter]]:\n    \"\"\"Get all USIT-specific channels and parameters from a DLIS logical file\n\n    Args:\n        file: The DLIS logical file to extract data from\n\n    Returns:\n        USIT channels as `LogChannel` objects, organized by frame in a dict, and USIT parameters in a dict\n    \"\"\"\n    usit_frame_channels = _get_usit_channels_by_frame(file)\n    usit_frame_curves = _get_usit_curves_by_frame(file, usit_frame_channels)\n    usit_frame_logchannels = _to_logchannels(file, usit_frame_channels, usit_frame_curves)\n    usit_parameters = _get_dlis_parameters(file, from_tool='.*USIT.*')\n\n    return usit_frame_logchannels, usit_parameters\n</code></pre>"},{"location":"api-pulseecho-data/#pyintegrity.pulseecho.usit.get_usit_series","title":"<code>pyintegrity.pulseecho.usit.get_usit_series(file)</code>","text":"<p>Assemble USIT waveform data into a <code>PulseEchoSeries</code> object</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>LogicalFile</code> <p>The DLIS logical file to extract data from</p> required <p>Returns:</p> Type Description <code>PulseEchoSeries</code> <p>A <code>PulseEchoSeries</code> object containing data about the waveforms and the assumed material and casing parameters</p> Source code in <code>src/pyintegrity/pulseecho/usit.py</code> <pre><code>def get_usit_series(file: dlis.LogicalFile) -&gt; PulseEchoSeries:\n    \"\"\"Assemble USIT waveform data into a `PulseEchoSeries` object\n\n    Args:\n        file: The DLIS logical file to extract data from\n\n    Returns:\n        A `PulseEchoSeries` object containing data about the waveforms and the assumed material and casing parameters\n    \"\"\"\n    usit_frame_channels = _get_usit_channels_by_frame(file)\n    usit_frame_curves = _get_usit_curves_by_frame(file, usit_frame_channels)\n\n    waveform_curve, waveform_t_0_curve, waveform_index_curve = _get_usit_waveforms(file, usit_frame_curves)\n\n    series = PulseEchoSeries(waveform_curve, sampling_freq=Quantity(2, 'MHz'),\n                             z=waveform_index_curve, t_0=waveform_t_0_curve)\n    series.casing = _get_casing(file)\n    series.inner_material = _get_inner_material(file, usit_frame_curves, waveform_index_curve)\n\n    return series\n</code></pre>"},{"location":"api-pulseecho-processing/","title":"Pulse-echo processing","text":"<p>This page describes the interface to the processing algorithms implemented as separate submodules in Pyintegrity:</p> <ul> <li>W2/W1 algorithm</li> <li>T3 algorithm</li> <li>ABCD algorithm</li> <li>L1 algorithm</li> </ul> <p>While the details of the algorithms are quite different, they all have a common interface. Each algorithm submodule includes a function <code>process_[algorithmname]</code> that accepts a <code>PulseEchoSeries</code> object (and in many cases other arguments as well) and returns an object of a <code>ProcessingResult</code> subclass:</p>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.result.ProcessingResult","title":"<code>pyintegrity.pulseecho.processing.result.ProcessingResult</code>","text":"<p>Generic result container to be subclassed by containers for specific algorithms</p> <p>Parameters:</p> Name Type Description Default <code>impedance</code> <code>LogChannel | None</code> <p>Impedance behind casing estimated by a processing algorithm</p> <code>None</code> <code>thickness</code> <code>LogChannel | None</code> <p>Casing thickness estimated by a processing algorithm</p> <code>None</code> Source code in <code>src/pyintegrity/pulseecho/processing/result.py</code> <pre><code>class ProcessingResult:\n    \"\"\"Generic result container to be subclassed by containers for specific algorithms\n\n    Args:\n        impedance: Impedance behind casing estimated by a processing algorithm\n        thickness: Casing thickness estimated by a processing algorithm\n    \"\"\"\n    def __init__(self,\n                 impedance: LogChannel | None = None,\n                 thickness: LogChannel | None = None) -&gt; None:\n        self.impedance = impedance\n        self.thickness = thickness\n</code></pre>"},{"location":"api-pulseecho-processing/#w2w1-algorithm","title":"W2/W1 algorithm","text":"<p>Module for W2/W1 processing of pulse-echo waveforms. This processing algorithm was first proposed by Havira (1981) and subsequently refined by later researchers. This module mainly follows the specification of Kimball (1992), but also uses the conversion between W2/W1 values and impedance specified by Catala et al. (1987).</p> <p>Furthermore, we have included an extension where W1 and W2 value may optionally be calculated from the waveform envelope instead of the rectified waveform as specified in the literature. The additional computational load is marginal, and it reduces random variations in W2.</p> <p>Note that the W2/W1 algorithm only provides an estimate of the impedance of the material behind the casing. It does not provide an estimate of the casing thickness.</p> <p>References:</p> <ul> <li>Havira, R.M. (1981): \u201cMethod and apparatus for acoustically investigating a casing and cement bond in a borehole\u201d.   US Patent 4,255,798.</li> <li>Catala, G., Stowe, I., Henry, D. (1987): \u201cMethod for evaluating the quality of cement surrounding the casing of a   borehole\u201d. US Patent 4,703,427.</li> <li>Kimball, C. V. (1992): \u201cImproved processing for oil well cement evaluation\u2014A study with theoretical and laboratory   data\u201d. In IEEE Transactions on Ultrasonics, Ferroelectrics, and Frequency Control vol. 39, no.1.</li> </ul>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.w2w1.W2W1Result","title":"<code>pyintegrity.pulseecho.processing.w2w1.W2W1Result</code>","text":"<p>             Bases: <code>ProcessingResult</code></p> <p>Result container for W2/W1 processing</p> <p>Parameters:</p> Name Type Description Default <code>w2w1</code> <code>LogChannel</code> <p>Raw W2/W1 values from processing, with no calibration applied</p> required <p>Attributes:</p> Name Type Description <code>w2w1</code> <code>LogChannel</code> <p>Raw W2/W1 for every waveform</p> <code>w2w1_fp</code> <code>Quantity | None</code> <p>Free-pipe value of W2/W1</p> <code>w2w1_cal</code> <code>LogChannel | None</code> <p>Raw W2/W1 normalized by free-pipe value of W2/W1</p> <code>impedance_fp</code> <code>Quantity | None</code> <p>Specified free-pipe impedance</p> Source code in <code>src/pyintegrity/pulseecho/processing/w2w1.py</code> <pre><code>class W2W1Result(ProcessingResult):\n    \"\"\"Result container for W2/W1 processing\n\n    Args:\n        w2w1: Raw W2/W1 values from processing, with no calibration applied\n\n    Attributes:\n        w2w1 (LogChannel): Raw W2/W1 for every waveform\n        w2w1_fp (Quantity | None): Free-pipe value of W2/W1\n        w2w1_cal (LogChannel | None): Raw W2/W1 normalized by free-pipe value of W2/W1\n        impedance_fp (Quantity | None): Specified free-pipe impedance\n    \"\"\"\n    def __init__(self, w2w1: LogChannel) -&gt; None:\n        super().__init__()                          # Initializes impedance behind casing and casing thickness\n        self.w2w1 = w2w1                            # Raw W2/W1 for every waveform\n        self.w2w1_fp: Quantity | None = None        # Free-pipe value of W2/W1\n        self.w2w1_cal: LogChannel | None = None     # Raw W2/W1 divided by free-pipe value of W2/W1\n        self.impedance_fp: Quantity | None = None   # Specified free-pipe impedance\n\n    def calibrate_w2w1(self,\n                       w2w1_fp: Quantity | None = None,\n                       interval_fp: tuple[float, float] | None = None\n                       ) -&gt; None:\n        \"\"\"Calibrate W2/W1 values by a free-pipe value which is provided or calculated from a provided depth interval\n\n        Args:\n            w2w1_fp: Provided free-pipe W2/W1 value\n            interval_fp: Free pipe interval to calculate W2/W1 value from if w2w1_fp is not specified\n        \"\"\"\n        if w2w1_fp is None:\n            if interval_fp is None:\n                raise ValueError('Either w2w1_fp or interval_fp must be not-None')\n            # Take the median W2/W1 value inside the free-pipe interval. (Median is robust to casing collar outliers.)\n            w2w1_fp = self.w2w1.data.sel(z=slice(interval_fp[0], interval_fp[1])).median().data\n\n        self.w2w1_fp = w2w1_fp\n        w2w1_cal = self.w2w1.copy()\n        w2w1_cal.data = self.w2w1.data / w2w1_fp\n        self.w2w1_cal = w2w1_cal\n\n    def calculate_impedance(self,\n                            series: PulseEchoSeries,\n                            impedance_fp: Quantity,\n                            factor_a: Quantity | None = None,\n                            factor_b: Quantity | None = None) -&gt; None:\n        \"\"\"Converts normalized W2/W1 values into impedance values\n\n        Args:\n            series: `PulseEchoSeries` object containing the waveform data\n            impedance_fp: Assumed free-pipe impedance value\n            factor_a: Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)\n            factor_b: Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)\n        \"\"\"\n        assert self.w2w1_cal is not None\n        assert series.casing is not None and series.casing.thickness_nominal is not None\n        thickness = series.casing.thickness_nominal\n\n        self.impedance_fp = impedance_fp\n        impedance = w2w1_to_impedance(self.w2w1_cal, thickness, impedance_fp, factor_a, factor_b)\n        self.impedance = LogChannel(impedance, z=self.w2w1.z, phi=self.w2w1.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.w2w1.W2W1Result.calculate_impedance","title":"<code>calculate_impedance(series, impedance_fp, factor_a=None, factor_b=None)</code>","text":"<p>Converts normalized W2/W1 values into impedance values</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required <code>impedance_fp</code> <code>Quantity</code> <p>Assumed free-pipe impedance value</p> required <code>factor_a</code> <code>Quantity | None</code> <p>Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)</p> <code>None</code> <code>factor_b</code> <code>Quantity | None</code> <p>Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)</p> <code>None</code> Source code in <code>src/pyintegrity/pulseecho/processing/w2w1.py</code> <pre><code>def calculate_impedance(self,\n                        series: PulseEchoSeries,\n                        impedance_fp: Quantity,\n                        factor_a: Quantity | None = None,\n                        factor_b: Quantity | None = None) -&gt; None:\n    \"\"\"Converts normalized W2/W1 values into impedance values\n\n    Args:\n        series: `PulseEchoSeries` object containing the waveform data\n        impedance_fp: Assumed free-pipe impedance value\n        factor_a: Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)\n        factor_b: Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)\n    \"\"\"\n    assert self.w2w1_cal is not None\n    assert series.casing is not None and series.casing.thickness_nominal is not None\n    thickness = series.casing.thickness_nominal\n\n    self.impedance_fp = impedance_fp\n    impedance = w2w1_to_impedance(self.w2w1_cal, thickness, impedance_fp, factor_a, factor_b)\n    self.impedance = LogChannel(impedance, z=self.w2w1.z, phi=self.w2w1.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.w2w1.W2W1Result.calibrate_w2w1","title":"<code>calibrate_w2w1(w2w1_fp=None, interval_fp=None)</code>","text":"<p>Calibrate W2/W1 values by a free-pipe value which is provided or calculated from a provided depth interval</p> <p>Parameters:</p> Name Type Description Default <code>w2w1_fp</code> <code>Quantity | None</code> <p>Provided free-pipe W2/W1 value</p> <code>None</code> <code>interval_fp</code> <code>tuple[float, float] | None</code> <p>Free pipe interval to calculate W2/W1 value from if w2w1_fp is not specified</p> <code>None</code> Source code in <code>src/pyintegrity/pulseecho/processing/w2w1.py</code> <pre><code>def calibrate_w2w1(self,\n                   w2w1_fp: Quantity | None = None,\n                   interval_fp: tuple[float, float] | None = None\n                   ) -&gt; None:\n    \"\"\"Calibrate W2/W1 values by a free-pipe value which is provided or calculated from a provided depth interval\n\n    Args:\n        w2w1_fp: Provided free-pipe W2/W1 value\n        interval_fp: Free pipe interval to calculate W2/W1 value from if w2w1_fp is not specified\n    \"\"\"\n    if w2w1_fp is None:\n        if interval_fp is None:\n            raise ValueError('Either w2w1_fp or interval_fp must be not-None')\n        # Take the median W2/W1 value inside the free-pipe interval. (Median is robust to casing collar outliers.)\n        w2w1_fp = self.w2w1.data.sel(z=slice(interval_fp[0], interval_fp[1])).median().data\n\n    self.w2w1_fp = w2w1_fp\n    w2w1_cal = self.w2w1.copy()\n    w2w1_cal.data = self.w2w1.data / w2w1_fp\n    self.w2w1_cal = w2w1_cal\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.w2w1.process_w2w1","title":"<code>pyintegrity.pulseecho.processing.w2w1.process_w2w1(series, use_envelope=False, w2w1_fp=None, interval_fp=None, impedance_fp=None, factor_a=None, factor_b=None)</code>","text":"<p>Perform W2/W1 on input waveform data</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <code>use_envelope</code> <code>bool</code> <p>Whether to perform W2/W1 processing on the waveform envelope or the rectified waveform</p> <code>False</code> <code>w2w1_fp</code> <code>Quantity | None</code> <p>Optional free-pipe W2/W1 value to use for normalization</p> <code>None</code> <code>interval_fp</code> <code>tuple[float, float] | None</code> <p>Optional free-pipe interval to calculate <code>w2w1_fp</code> from if it is not specified</p> <code>None</code> <code>impedance_fp</code> <code>Quantity | None</code> <p>The reference impedance value in the free-pipe interval</p> <code>None</code> <code>factor_a</code> <code>Quantity | None</code> <p>Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)</p> <code>None</code> <code>factor_b</code> <code>Quantity | None</code> <p>Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)</p> <code>None</code> <p>Returns:</p> Type Description <code>W2W1Result</code> <p>A <code>W2W1Result</code> object with the processing results</p> Source code in <code>src/pyintegrity/pulseecho/processing/w2w1.py</code> <pre><code>def process_w2w1(series: PulseEchoSeries,\n                 use_envelope: bool = False,\n                 w2w1_fp: Quantity | None = None,\n                 interval_fp: tuple[float, float] | None = None,\n                 impedance_fp: Quantity | None = None,\n                 factor_a: Quantity | None = None,\n                 factor_b: Quantity | None = None\n                 ) -&gt; W2W1Result:\n    \"\"\"Perform W2/W1 on input waveform data\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n        use_envelope: Whether to perform W2/W1 processing on the waveform envelope or the rectified waveform\n        w2w1_fp: Optional free-pipe W2/W1 value to use for normalization\n        interval_fp: Optional free-pipe interval to calculate `w2w1_fp` from if it is not specified\n        impedance_fp: The reference impedance value in the free-pipe interval\n        factor_a: Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)\n        factor_b: Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)\n\n    Returns:\n        A `W2W1Result` object with the processing results\n    \"\"\"\n    waveforms = series.data.to_numpy()   # depth-angle-time array of waveforms\n    if use_envelope:\n        signals = np.abs(hilbert(waveforms, axis=2))\n    else:\n        signals = np.abs(waveforms)\n\n    w1s, k_w1s = _get_w1(signals, waveforms)\n    last_zero_crossings = _previous_zero_crossing(waveforms, k_w1s, axis=2)   #pylint: disable=typecheck\n    w2s = _get_w2(signals, last_zero_crossings, series)\n\n    w2w1 = LogChannel(w2s/w1s, z=series.z, phi=series.phi)\n    result = W2W1Result(w2w1)\n\n    # Normalize W2/W1 against its free-pipe value\n    if w2w1_fp is None and interval_fp is None:   # Not possible to calculate free-pipe W2/W1 value\n        return result   # W2/W1 calculation cannot proceed any further\n    result.calibrate_w2w1(w2w1_fp=w2w1_fp, interval_fp=interval_fp)\n\n    # Calculate impedance from normalized W2/W1 values\n    if impedance_fp is None:   # No specified free-pipe impedance\n        return result   # W2/W1 calculation cannot proceed any further\n    result.calculate_impedance(series, impedance_fp, factor_a, factor_b)\n\n    return result\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.w2w1.w2w1_to_impedance","title":"<code>pyintegrity.pulseecho.processing.w2w1.w2w1_to_impedance(w2w1_cal, casing_thickness, impedance_fp=Quantity(1.5, 'MRayl'), factor_a=None, factor_b=None)</code>","text":"<p>Convert from normalized W2/W1 values to impedance following Catala et al. (1987)</p> <p>Parameters:</p> Name Type Description Default <code>w2w1_cal</code> <code>LogChannel | ndarray</code> <p>(W2/W1) / (W2/W1)_fp values, (W2/W1)_fp being the assumed free-pipe value of W2/W1</p> required <code>casing_thickness</code> <code>Quantity</code> <p>The thickness of the logged casing</p> required <code>impedance_fp</code> <code>Quantity</code> <p>The assumed impedance beyond the casing in a free-pipe section</p> <code>Quantity(1.5, 'MRayl')</code> <code>factor_a</code> <code>Quantity | None</code> <p>Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)</p> <code>None</code> <code>factor_b</code> <code>Quantity | None</code> <p>Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)</p> <code>None</code> Source code in <code>src/pyintegrity/pulseecho/processing/w2w1.py</code> <pre><code>def w2w1_to_impedance(w2w1_cal: LogChannel | np.ndarray,\n                      casing_thickness: Quantity,\n                      impedance_fp: Quantity = Quantity(1.5, 'MRayl'),\n                      factor_a: Quantity | None = None,\n                      factor_b: Quantity | None = None) -&gt; Quantity:\n    \"\"\"Convert from normalized W2/W1 values to impedance following Catala et al. (1987)\n\n    Args:\n        w2w1_cal: (W2/W1) / (W2/W1)_fp values, (W2/W1)_fp being the assumed free-pipe value of W2/W1\n        casing_thickness: The thickness of the logged casing\n        impedance_fp: The assumed impedance beyond the casing in a free-pipe section\n        factor_a: Factor for casing thickness and logarithmic W2/W1; corresponds to A in Catala et al. (1987)\n        factor_b: Factor for logarithmic W2/W1; corresponds to B in Catala et al. (1987)\n    \"\"\"\n    if factor_a is None:\n        factor_a = Quantity(0.3, 'kg/mm^3/s')   # Default value from Catala et al. (1987)\n    if factor_b is None:\n        factor_b = Quantity(0.2, 'kg/mm^2/s')   # Default value from Catala et al. (1987)\n\n    if isinstance(w2w1_cal, LogChannel):\n        w2w1_cal = w2w1_cal.to_numpy()\n    factor_c = (factor_a * casing_thickness.to('mm') + factor_b).to('MRayl')\n    return impedance_fp - factor_c * np.log(w2w1_cal)\n</code></pre>"},{"location":"api-pulseecho-processing/#t3-algorithm","title":"T<sup>3</sup> algorithm","text":"<p>Module for T3 processing following the description in Hayman (1991) and Wright (1993). The algorithm is based on the derivation of the group delay curve to derive  thickness and impedance</p> <p>Hayman, A., Hutin, R., Wright, P., 1991. High-resolution cementation and corrosion imaging by ultrasound, in: SPWLA 32th Annual Logging Symposium, p. 25.</p> <p>Wright, P., 1993. Method and apparatus for the acoustic investigation of a casing cemented in a borehole. US Patent No. 5,216,638.</p>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3result","title":"<code>pyintegrity.pulseecho.processing.t3.T3result</code>","text":"<p>             Bases: <code>ProcessingResult</code></p> <p>Result container for T3 processing</p> <p>Parameters:</p> Name Type Description Default <code>band</code> <code>LogChannel</code> <p>bandwidth of group delay minimum</p> required <code>fres</code> <code>LogChannel</code> <p>resonance frequency derived from group-delay minimum</p> required <code>Spec_firstpulse</code> <code>LogChannel</code> <p>the spectrum from the first pulse used in the convolution with the 1D model</p> required Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>class T3result(ProcessingResult):\n    \"\"\"Result container for T3 processing\n\n    Args:\n        band: bandwidth of group delay minimum\n        fres: resonance frequency derived from group-delay minimum\n        Spec_firstpulse: the spectrum from the first pulse used in the convolution with the 1D model\n    \"\"\"\n    def __init__(self, band: LogChannel,\n                    fres: LogChannel,\n                    Spec_firstpulse: LogChannel)-&gt; None: \n        super().__init__()                          # Initializes impedance behind casing and casing thickness\n\n        self.band= band\n        self.fres= fres\n        self.Spec_firstpulse= Spec_firstpulse\n\n    def derive_impedance_thickness(self,series: PulseEchoSeries,\n                          T3band_meas: Quantity,\n                          T3freq: Quantity,\n                          f_search: tuple[float, float],\n                          indT_S0: np.ndarray,\n                          indT_S1: np.ndarray,\n                          indT_N0: np.ndarray,\n                          indT_N1: np.ndarray) -&gt; None:\n        \"\"\"Derive impedance using group delay parameters through optimization algorithm \n\n        Args: \n            series: `PulseEchoSeries` object containing the waveform data\n            T3band_meas: bandwidth derived form measured data   \n            T3freq: frequency vector\n            f_search: window limits for search area\n            indT_S0: signal window start\n            indT_S1: signal window end\n            indT_N0: normalization window start\n            indT_N1: normalisation window end\n        \"\"\"\n        assert series.casing is not None and series.casing.material is not None \\\n            and series.casing.material.speed is not None and series.casing.material.impedance is not None\n        assert series.casing.thickness_nominal is not None\n        assert series.inner_material is not None and series.inner_material.impedance is not None\n\n        fres_meas=self.fres.data.to_numpy()\n        T3N=self.Spec_firstpulse.to_numpy()\n        f_exp= series.casing.material.speed/(2*series.casing.thickness_nominal)\n        # Optimization to derive outer-material impedance and pipe thickness\n        d= series.casing.material.speed.magnitude/2/(fres_meas)  # derive thickness from group delay resonance\n\n        [M,N]=T3band_meas.shape\n        Z_res=np.zeros([M,N])\n        d_res=np.zeros([M,N])\n\n        for i in prange(M):   # pylint: disable=not-an-iterable\n            for j in prange(N):   # pylint: disable=not-an-iterable\n                if ~np.isnan(d[i,j]):\n                    initial_val =[5*10**6, d[i,j]]\n\n                    indT_S=[indT_S0[i,j],indT_S1[i,j]]\n                    indT_N=[indT_N0[i,j],indT_N1[i,j]]\n                    try:\n                        argsH=(series.casing.material.impedance.magnitude,\n                               series.inner_material.impedance.magnitude[i],\n                               series.casing.material.speed.magnitude,\n                               indT_S, indT_N,T3N[i,j,:],\n                               f_exp.magnitude,\n                               T3freq.magnitude,\n                               fres_meas[i,j],\n                               f_search,\n                               T3band_meas.magnitude[i,j])\n                        final_T3 = minimize(T3_optimize, initial_val, args=argsH,method='Nelder-Mead',tol=1000)\n                        Z_res[i,j]=final_T3.x[0]*10**-6\n                        d_res[i,j]=final_T3.x[1]\n\n                    except:   # FIXME: Specify exception type   # pylint: disable=bare-except\n                        Z_res[i,j]=np.nan\n                        d_res[i,j]=np.nan\n                else:\n                    Z_res[i,j]=np.nan\n                    d_res[i,j]=np.nan\n        self.impedance = LogChannel(Quantity(Z_res,'MRayl'), z=series.z, phi=series.phi)\n        self.thickness = LogChannel(Quantity(d_res,'m'), z=series.z, phi=series.phi)\n\n    def calculate_thickness_fres(self,series: PulseEchoSeries) -&gt; None:\n        \"\"\"Calculate thickness from resonance frequency\n\n        Args: \n            series: `PulseEchoSeries` object containing the waveform data\n        \"\"\"\n        assert series.casing is not None and series.casing.material is not None \\\n            and series.casing.material.speed is not None\n\n        d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n        self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3result.calculate_thickness_fres","title":"<code>calculate_thickness_fres(series)</code>","text":"<p>Calculate thickness from resonance frequency</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def calculate_thickness_fres(self,series: PulseEchoSeries) -&gt; None:\n    \"\"\"Calculate thickness from resonance frequency\n\n    Args: \n        series: `PulseEchoSeries` object containing the waveform data\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.material.speed is not None\n\n    d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n    self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3result.derive_impedance_thickness","title":"<code>derive_impedance_thickness(series, T3band_meas, T3freq, f_search, indT_S0, indT_S1, indT_N0, indT_N1)</code>","text":"<p>Derive impedance using group delay parameters through optimization algorithm </p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required <code>T3band_meas</code> <code>Quantity</code> <p>bandwidth derived form measured data   </p> required <code>T3freq</code> <code>Quantity</code> <p>frequency vector</p> required <code>f_search</code> <code>tuple[float, float]</code> <p>window limits for search area</p> required <code>indT_S0</code> <code>ndarray</code> <p>signal window start</p> required <code>indT_S1</code> <code>ndarray</code> <p>signal window end</p> required <code>indT_N0</code> <code>ndarray</code> <p>normalization window start</p> required <code>indT_N1</code> <code>ndarray</code> <p>normalisation window end</p> required Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def derive_impedance_thickness(self,series: PulseEchoSeries,\n                      T3band_meas: Quantity,\n                      T3freq: Quantity,\n                      f_search: tuple[float, float],\n                      indT_S0: np.ndarray,\n                      indT_S1: np.ndarray,\n                      indT_N0: np.ndarray,\n                      indT_N1: np.ndarray) -&gt; None:\n    \"\"\"Derive impedance using group delay parameters through optimization algorithm \n\n    Args: \n        series: `PulseEchoSeries` object containing the waveform data\n        T3band_meas: bandwidth derived form measured data   \n        T3freq: frequency vector\n        f_search: window limits for search area\n        indT_S0: signal window start\n        indT_S1: signal window end\n        indT_N0: normalization window start\n        indT_N1: normalisation window end\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.material.speed is not None and series.casing.material.impedance is not None\n    assert series.casing.thickness_nominal is not None\n    assert series.inner_material is not None and series.inner_material.impedance is not None\n\n    fres_meas=self.fres.data.to_numpy()\n    T3N=self.Spec_firstpulse.to_numpy()\n    f_exp= series.casing.material.speed/(2*series.casing.thickness_nominal)\n    # Optimization to derive outer-material impedance and pipe thickness\n    d= series.casing.material.speed.magnitude/2/(fres_meas)  # derive thickness from group delay resonance\n\n    [M,N]=T3band_meas.shape\n    Z_res=np.zeros([M,N])\n    d_res=np.zeros([M,N])\n\n    for i in prange(M):   # pylint: disable=not-an-iterable\n        for j in prange(N):   # pylint: disable=not-an-iterable\n            if ~np.isnan(d[i,j]):\n                initial_val =[5*10**6, d[i,j]]\n\n                indT_S=[indT_S0[i,j],indT_S1[i,j]]\n                indT_N=[indT_N0[i,j],indT_N1[i,j]]\n                try:\n                    argsH=(series.casing.material.impedance.magnitude,\n                           series.inner_material.impedance.magnitude[i],\n                           series.casing.material.speed.magnitude,\n                           indT_S, indT_N,T3N[i,j,:],\n                           f_exp.magnitude,\n                           T3freq.magnitude,\n                           fres_meas[i,j],\n                           f_search,\n                           T3band_meas.magnitude[i,j])\n                    final_T3 = minimize(T3_optimize, initial_val, args=argsH,method='Nelder-Mead',tol=1000)\n                    Z_res[i,j]=final_T3.x[0]*10**-6\n                    d_res[i,j]=final_T3.x[1]\n\n                except:   # FIXME: Specify exception type   # pylint: disable=bare-except\n                    Z_res[i,j]=np.nan\n                    d_res[i,j]=np.nan\n            else:\n                Z_res[i,j]=np.nan\n                d_res[i,j]=np.nan\n    self.impedance = LogChannel(Quantity(Z_res,'MRayl'), z=series.z, phi=series.phi)\n    self.thickness = LogChannel(Quantity(d_res,'m'), z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.PreStep_processing","title":"<code>pyintegrity.pulseecho.processing.t3.PreStep_processing(series, lim_win, scale)</code>","text":"<p>Preprocessing of the data to derive group delay curve, resonance frequency, group delay minimum and         bandwidth of minimum</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <code>lim_win</code> <code>tuple[float, float]</code> <p>window limits in periods for normalization and signal window</p> required <code>scale</code> <code>int</code> <p>scale of frequency resolution</p> required <p>Returns:</p> Name Type Description <code>T3freq</code> <code>Quantity</code> <p>Frequency vector corresponding to the spectrum</p> <code>T3taugSN</code> <code>Quantity</code> <p>group delay curve</p> <code>T3N</code> <code>ndarray</code> <p>normalization spectrum, spectrum of the first pulse</p> <code>indT_S0</code> <code>ndarray</code> <p>start signal window</p> <code>indT_S1</code> <code>ndarray</code> <p>stop signal window</p> <code>indT_N0</code> <code>ndarray</code> <p>start normalization window</p> <code>indT_N1</code> <code>ndarray</code> <p>stop normalization window</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def PreStep_processing(series: PulseEchoSeries, lim_win:tuple[float,float], scale: int\n                       ) -&gt; tuple[Quantity, Quantity, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\" Preprocessing of the data to derive group delay curve, resonance frequency, group delay minimum and \\\n        bandwidth of minimum\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n        lim_win: window limits in periods for normalization and signal window\n        scale: scale of frequency resolution\n\n    Returns:\n        T3freq: Frequency vector corresponding to the spectrum\n        T3taugSN: group delay curve\n        T3N: normalization spectrum, spectrum of the first pulse\n        indT_S0: start signal window\n        indT_S1: stop signal window\n        indT_N0: start normalization window\n        indT_N1: stop normalization window\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None and series.casing.material.speed is not None\n    assert series.casing.thickness_nominal is not None\n\n    N_per=lim_win[0]\n    S_per=lim_win[1]\n\n    ### Step1 ###\n    dt = 1/series.sampling_freq\n    f_exp = series.casing.material.speed/(2*series.casing.thickness_nominal)\n    waveforms = series.data.to_numpy()\n    t = series.data.t.to_numpy()\n\n    [M,N,Nfft]=waveforms.shape\n\n\n    env = np.abs(hilbert(waveforms))\n    env= 20*np.log10(env)\n    T3t_max,_ = find_peak(t,env)\n    t_help=np.append(np.arange(-dt.magnitude*len(t),0,dt.magnitude), t)[np.newaxis,np.newaxis,:]\n\n    ### Step2,3 ###\n    # find window length for normalization and signal window\n    per = 1/f_exp.magnitude\n    T3t_N = [T3t_max-(N_per*per), T3t_max+(N_per*per)]\n    indT_N = [np.argmin(np.abs(t_help - T3t_N[0][:,:,np.newaxis]),axis=-1),   # First sample index of the range\n              np.argmin(np.abs(t_help - T3t_N[1][:,:,np.newaxis]),axis=-1)]\n    indT_N0=indT_N[0]-Nfft\n    indT_N1=indT_N[1]-Nfft\n\n    T3t_S = [T3t_max-(S_per*per), T3t_max+(S_per*per)]\n    indT_S = [np.argmin(np.abs(t_help - T3t_S[0][:,:,np.newaxis]),axis=-1),   # First sample index of the range\n              np.argmin(np.abs(t_help - T3t_S[1][:,:,np.newaxis]),axis=-1)]\n    indT_S0=indT_S[0]-Nfft\n    indT_S1=indT_S[1]-Nfft\n\n    # Upscaling \n    NfftS=Nfft*scale\n    waveformsScale=np.zeros([M,N,NfftS])\n    waveformsScale[:,:,0:Nfft]=waveforms\n\n    NfftS2=int(NfftS/2+1)\n    T3N=_nom_Spec(indT_N0,indT_N1,NfftS,waveformsScale)[:,:,:NfftS2]   # pylint: disable=typecheck\n    T3S=_sig_Spec(indT_S0,indT_S1,indT_N0,NfftS,waveformsScale)[:,:,:NfftS2]   # pylint: disable=typecheck\n\n    T3freq=np.arange(0,NfftS2)/NfftS/((dt))\n    df=T3freq[1]-T3freq[0]\n\n    T3SN = T3S/T3N\n    phirSN = np.unwrap(np.angle(T3SN))\n\n    T3taugSN = (phirSN[:,:,1::]-phirSN[:,:,0:-1:])/(2*np.pi*df) \n\n    return T3freq,T3taugSN, T3N, indT_S0, indT_S1, indT_N0, indT_N1\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_band","title":"<code>pyintegrity.pulseecho.processing.t3.T3_band(f, tauF, taumin, T3taugSN)</code>","text":"<p>Calculating the bandwidth og the group delay minimum</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Quantity</code> <p>Frequency vector corresponding to the spectrum</p> required <code>tauF</code> <code>Quantity</code> <p>resonance frequency of group delay minimum</p> required <code>taumin</code> <code>Quantity</code> <p>group delay minimum</p> required <code>T3taugSN</code> <code>Quantity</code> <p>group delay curve</p> required <p>Returns:</p> Name Type Description <code>band</code> <code>Quantity</code> <p>bandwidth of group delay minimum</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_band(f: Quantity,tauF: Quantity,taumin: Quantity,T3taugSN: Quantity) -&gt; Quantity:\n    \"\"\" Calculating the bandwidth og the group delay minimum\n\n    Args:\n        f: Frequency vector corresponding to the spectrum\n        tauF: resonance frequency of group delay minimum\n        taumin: group delay minimum\n        T3taugSN: group delay curve\n\n    Returns:\n        band: bandwidth of group delay minimum\n    \"\"\"\n    df=f[1]-f[0]\n    f_fit = (tauF.magnitude-tauF.magnitude*1/3,tauF.magnitude+tauF.magnitude*1/3)\n    fstart = np.argmin(np.abs(f.magnitude[np.newaxis, np.newaxis, :]-f_fit[0][:, :, np.newaxis]),axis=-1)\n    fstop =  np.argmin(np.abs(f.magnitude[np.newaxis, np.newaxis, :]-f_fit[1][:, :, np.newaxis]),axis=-1)\n\n    band=_get_band(T3taugSN.magnitude, taumin.magnitude, fstart, fstop, df.magnitude)   # pylint: disable=typecheck\n    band=Quantity(band,'Hz')\n    return band   \n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_band1","title":"<code>pyintegrity.pulseecho.processing.t3.T3_band1(f, tauF, taumin, T3taugSN)</code>","text":"<p>Calculating the bandwidth and the group delay minimum for one trace</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>tauF</code> <code>float</code> <p>resonance frequency of group delay minimum</p> required <code>taumin</code> <code>float</code> <p>group delay minimum</p> required <code>T3taugSN</code> <code>ndarray</code> <p>group delay curve</p> required <p>Returns:</p> Name Type Description <code>band</code> <code>float</code> <p>bandwidth of group delay minimum</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>@njit\ndef T3_band1(f: np.ndarray ,tauF: float, taumin: float, T3taugSN: np.ndarray) -&gt; float:\n    \"\"\" Calculating the bandwidth and the group delay minimum for one trace\n\n    Args:\n        f: Frequency vector corresponding to the spectrum\n        tauF: resonance frequency of group delay minimum\n        taumin: group delay minimum\n        T3taugSN: group delay curve\n\n    Returns:\n        band: bandwidth of group delay minimum\n    \"\"\"\n    df=f[1]-f[0]\n    f_fit = (tauF-tauF*1/3,tauF+tauF*1/3)\n\n    fstart = np.argmin(np.abs(f-f_fit[0]))\n    fstop =  np.argmin(np.abs(f-f_fit[1]))\n\n    if np.isnan(taumin):\n        band=np.nan\n    else:\n        i_range=np.arange(fstart,fstop)\n        peak40 = taumin /100*60 # 40 % from maximum\n        taudiff=-T3taugSN[i_range]-peak40\n        taucr = np.where(np.sign(taudiff[:-1]) != np.sign(taudiff[1:]))[0] \n        if len(taucr)&lt;=1:\n            band=np.nan\n        else:\n            taucrU=np.zeros(2)\n            taucrU[0]=taucr[0] + (np.abs(taudiff[taucr[0]])*100\n                                  / (np.abs(taudiff[taucr[0]])+np.abs(taudiff[taucr[0]+1]))\n                                  ) / 100\n            taucrU[1]=taucr[1] + (np.abs(taudiff[taucr[1]])*100\n                                  / (np.abs(taudiff[taucr[1]])+np.abs(taudiff[taucr[1]+1]))\n                                  ) / 100\n            band = (taucrU[1]-taucrU[0])*df \n    return band  \n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_model","title":"<code>pyintegrity.pulseecho.processing.t3.T3_model(in_val, Zcas, Zin, v_cas, indT_S, indT_N, T3N_w, f0, f, f_search)</code>","text":"<p>Deriving modelled group delay curve and determining, resonance frequency, minimum value and bandwidth from the         modelled data</p> <p>Parameters:</p> Name Type Description Default <code>in_val</code> <code>list</code> <p>list of input parameters to derive impedance and thickness</p> required <code>Zcas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner material</p> required <code>v_cas</code> <code>float</code> <p>P-wave speed of casing</p> required <code>indT_S</code> <code>list</code> <p>list of start and stop for signal window</p> required <code>indT_N</code> <code>list</code> <p>list of start and stop for normalization window</p> required <code>T3N_w</code> <code>ndarray</code> <p>spectrum of initial reflection</p> required <code>f0</code> <code>float</code> <p>expected resonance frequency</p> required <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>f_search</code> <code>list</code> <p>search window for group delay minimum as plus-minus from</p> required <p>Returns:</p> Name Type Description <code>tauF_mod</code> <code>float</code> <p>frequency of group delay minimum from modelled data</p> <code>band_mod</code> <code>float</code> <p>bandwidth of group delay minimum from modelled data</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_model(in_val: list, Zcas: float, Zin: float, v_cas: float, indT_S: list, indT_N: list, T3N_w: np.ndarray, \n             f0: float, f: np.ndarray, f_search: list) -&gt; tuple[float, float]:\n    \"\"\" Deriving modelled group delay curve and determining, resonance frequency, minimum value and bandwidth from the \\\n        modelled data\n\n    Args:\n        in_val: list of input parameters to derive impedance and thickness\n        Zcas: impedance of casing\n        Zin: impedance of inner material\n        v_cas: P-wave speed of casing\n        indT_S: list of start and stop for signal window\n        indT_N: list of start and stop for normalization window\n        T3N_w: spectrum of initial reflection\n        f0: expected resonance frequency\n        f: Frequency vector corresponding to the spectrum\n        f_search: search window for group delay minimum as plus-minus from\n\n    Returns:\n        tauF_mod: frequency of group delay minimum from modelled data\n        band_mod: bandwidth of group delay minimum from modelled data\n    \"\"\"\n    Zfo=in_val[0]*10**-6\n    d_cas=in_val[1]\n    # plane wave model estimation of reflection coefficent\n    ref_coeff = T3_planewavemodel(f,d_cas,v_cas,Zcas,Zin,Zfo)\n    # calculation of group delay\n    T3taugSN_mod = T3_model_group_delay(f,ref_coeff,T3N_w,indT_S, indT_N)\n    # derive resonance frequency and group delay minimum\n    tauF_mod,taumin_mod=T3_tauF_tauMin1(f, f0, f_search, T3taugSN_mod)\n\n    # derive band from model data\n    band_mod=T3_band1(f, tauF_mod,taumin_mod, T3taugSN_mod)\n    return tauF_mod,band_mod\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_model_group_delay","title":"<code>pyintegrity.pulseecho.processing.t3.T3_model_group_delay(f, ref_coeff, T3N_w, indT_S, indT_N)</code>","text":"<p>Deriving group delay from modelled plane wave reflection coefficient</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>ref_coeff</code> <code>ndarray</code> <p>1D modelled reflection coefficient</p> required <code>T3N_w</code> <code>ndarray</code> <p>spectrum of initial reflection</p> required <code>indT_S</code> <code>list</code> <p>list of start and stop for signal window</p> required <code>indT_N</code> <code>list</code> <p>list of start and stop for normalization window</p> required <p>Returns:</p> Name Type Description <code>T3taugSN_mod</code> <code>ndarray</code> <p>modelled group delay</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_model_group_delay(f: np.ndarray, ref_coeff: np.ndarray, T3N_w: np.ndarray, indT_S: list, indT_N: list\n                         ) -&gt; np.ndarray:\n    \"\"\" Deriving group delay from modelled plane wave reflection coefficient\n\n    Args:        \n        f: Frequency vector corresponding to the spectrum\n        ref_coeff: 1D modelled reflection coefficient\n        T3N_w: spectrum of initial reflection\n        indT_S: list of start and stop for signal window\n        indT_N: list of start and stop for normalization window\n\n    Returns:\n        T3taugSN_mod: modelled group delay\n    \"\"\"\n    S_ham=np.hamming(indT_S[1]- indT_S[0])\n    df=f[1]-f[0]\n    Nfft=len(f)\n    TSN=_step2(ref_coeff,T3N_w,Nfft,S_ham,indT_S[0],indT_S[1],indT_N[0]) \n    step3 = np.zeros(Nfft)\n    step3 = _angle_unwrap1(np.angle(TSN))\n\n    T3taugSN_mod = (step3[1::]-step3[0:-1:])/(2*np.pi*df)\n\n    return T3taugSN_mod    \n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_optimize","title":"<code>pyintegrity.pulseecho.processing.t3.T3_optimize(in_val, Zcas, Zin, v_cas, indT_S, indT_N, T3N_w, f0, f, T3f0_meas, f_search, T3band_meas)</code>","text":"<p>Algorithm that calls model to optimize error between real data and model data to find the best estimate for         impedance and thickness</p> <p>Parameters:</p> Name Type Description Default <code>in_val</code> <code>list</code> <p>list of input parameters to derive impedance and thickness</p> required <code>Zcas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner material</p> required <code>v_cas</code> <code>float</code> <p>P-wave speed of casing</p> required <code>indT_S</code> <code>list</code> <p>list of start and stop for signal window</p> required <code>indT_N</code> <code>list</code> <p>list of start and stop for normalization window</p> required <code>indT_S</code> <code>list</code> <p>list of start and stop for signal window</p> required <code>f0</code> <code>float</code> <p>expected resonance frequency</p> required <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>T3f0_meas</code> <code>float</code> <p>resonance frequency derived from measured data</p> required <code>f_search</code> <code>list</code> <p>search window for group delay minimum as plus-minus from </p> required <code>T3band_meas</code> <code>float</code> <p>bandwidth of group-delay minimum of measured data</p> required <p>Returns:</p> Type Description <code>float</code> <p>error between resonance frequency and group delay minimum of measured and modelled data</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_optimize(in_val: list, Zcas: float ,Zin: float, v_cas: float, indT_S: list, indT_N: list, T3N_w: np.ndarray, \\\n                f0: float, f: np.ndarray, T3f0_meas: float, f_search: list, T3band_meas: float) -&gt; float:\n    \"\"\" Algorithm that calls model to optimize error between real data and model data to find the best estimate for \\\n        impedance and thickness\n\n    Args:\n        in_val: list of input parameters to derive impedance and thickness\n        Zcas: impedance of casing\n        Zin: impedance of inner material\n        v_cas: P-wave speed of casing\n        indT_S: list of start and stop for signal window\n        indT_N: list of start and stop for normalization window\n        indT_S: list of start and stop for signal window\n        f0: expected resonance frequency\n        f: Frequency vector corresponding to the spectrum\n        T3f0_meas: resonance frequency derived from measured data\n        f_search: search window for group delay minimum as plus-minus from \n        T3band_meas: bandwidth of group-delay minimum of measured data\n\n    Returns:\n        error between resonance frequency and group delay minimum of measured and modelled data\n    \"\"\"\n    T3f0_model,T3band_model=T3_model(in_val,Zcas,Zin,v_cas,indT_S, indT_N,T3N_w,f0,f,f_search)\n    return ( ((T3f0_model-T3f0_meas)/T3f0_meas)**2 \\\n            + ((T3band_model/T3f0_model-T3band_meas/T3f0_meas)/(T3band_meas/T3f0_meas))**2 \\\n            )**2\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_planewavemodel","title":"<code>pyintegrity.pulseecho.processing.t3.T3_planewavemodel(f, d_cas, v_cas, Zcas, Zin, Zfo)</code>","text":"<p>Reflection coefficient from 1D model</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>d_cas</code> <code>float</code> <p>derived pipe thickness</p> required <code>v_cas</code> <code>float</code> <p>P-wave speed of casing</p> required <code>Zcas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner material</p> required <code>Zfo</code> <code>float</code> <p>outer material impedance guess</p> required <p>Returns:</p> Name Type Description <code>ref_coeff</code> <code>ndarray</code> <p>1D modelled reflection coefficient</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>@njit\ndef T3_planewavemodel(f: np.ndarray, d_cas: float, v_cas: float, Zcas: float, Zin: float, Zfo: float) -&gt; np.ndarray:  \n    \"\"\" Reflection coefficient from 1D model\n\n    Args:        \n        f: Frequency vector corresponding to the spectrum\n        d_cas: derived pipe thickness\n        v_cas: P-wave speed of casing\n        Zcas: impedance of casing\n        Zin: impedance of inner material\n        Zfo: outer material impedance guess\n\n    Returns:\n        ref_coeff: 1D modelled reflection coefficient\n    \"\"\"\n    ckd = np.cos((2 * np.pi * f) / v_cas *d_cas)\n    skd = np.sin((2 * np.pi * f) / v_cas *d_cas)\n    ref_coeff = ( ((1 - Zin/Zfo) * ckd) + ((Zcas/Zfo - Zin/Zcas) * skd * 1j)) \\\n                / ( ((1 + Zin/Zfo) * ckd) + ((Zcas/Zfo + Zin/Zcas) * skd * 1j))\n    return ref_coeff\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_tauF_tauMin","title":"<code>pyintegrity.pulseecho.processing.t3.T3_tauF_tauMin(f, f0, f_search, T3taugSN)</code>","text":"<p>Deriving resonance frequency and group delay minimum</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Quantity</code> <p>Frequency vector corresponding to the spectrum</p> required <code>f0</code> <code>Quantity</code> <p>expected resonance frequency</p> required <code>f_search</code> <code>tuple[float, float]</code> <p>search window for group delay minimum as plus-minus from expected resonance frequency</p> required <code>T3taugSN</code> <code>Quantity</code> <p>group delay curve   </p> required <p>Returns:</p> Name Type Description <code>tauF</code> <code>Quantity</code> <p>resonance frequency from group delay minimum</p> <code>taumin</code> <code>Quantity</code> <p>group delay minimum</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_tauF_tauMin(f: Quantity, f0: Quantity, f_search: tuple[float, float], T3taugSN:Quantity\n                   ) -&gt; tuple[Quantity, Quantity]:\n    \"\"\" Deriving resonance frequency and group delay minimum\n\n    Args:\n        f: Frequency vector corresponding to the spectrum\n        f0: expected resonance frequency\n        f_search: search window for group delay minimum as plus-minus from expected resonance frequency\n        T3taugSN: group delay curve   \n\n    Returns:\n        tauF: resonance frequency from group delay minimum\n        taumin: group delay minimum\n    \"\"\"\n    # Get tau frequency and tau minimum\n    f_fit = (f0.magnitude+f_search[0],f0.magnitude+f_search[1])\n    fstart = np.argmin(np.abs(f.magnitude-f_fit[0]))\n    fstop =  np.argmin(np.abs(f.magnitude-f_fit[1]))    \n    i_range=np.arange(fstart,fstop)\n    if T3taugSN.ndim==3:\n        tauF,taumin=find_peak(f[i_range],T3taugSN[:,:,i_range])\n    else:\n        tauF,taumin=find_peak(f[i_range],T3taugSN[i_range])    \n    return tauF,-taumin   # type: ignore[return-value]\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.T3_tauF_tauMin1","title":"<code>pyintegrity.pulseecho.processing.t3.T3_tauF_tauMin1(f, f0, f_search, T3taugSN)</code>","text":"<p>Deriving resonance frequency and group delay minimum for one dataset</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Frequency vector corresponding to the spectrum</p> required <code>f0</code> <code>float</code> <p>expected resonance frequency</p> required <code>f_search</code> <code>list</code> <p>search window for group delay minimum as plus-minus from expected resonance frequency</p> required <code>T3taugSN</code> <code>ndarray</code> <p>group delay curve   </p> required <p>Returns:</p> Name Type Description <code>tauF</code> <code>float</code> <p>resonance frequency from group delay minimum</p> <code>taumin</code> <code>float</code> <p>group delay minimum</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def T3_tauF_tauMin1(f: np.ndarray, f0: float, f_search: list, T3taugSN: np.ndarray) -&gt; tuple[float, float]:\n    \"\"\" Deriving resonance frequency and group delay minimum for one dataset\n\n    Args:\n        f: Frequency vector corresponding to the spectrum\n        f0: expected resonance frequency\n        f_search: search window for group delay minimum as plus-minus from expected resonance frequency\n        T3taugSN: group delay curve   \n\n    Returns:\n        tauF: resonance frequency from group delay minimum\n        taumin: group delay minimum\n    \"\"\"\n    # Get tau frequency and tau minimum\n    f_fit = (f0+f_search[0],f0+f_search[1])\n    fstart = np.argmin(np.abs(f-f_fit[0]))\n    fstop =  np.argmin(np.abs(f-f_fit[1]))    \n    i_range=np.arange(fstart,fstop)\n    tauF,taumin=find_peak(f[i_range],T3taugSN[i_range])    \n    return tauF,-taumin   # type: ignore[return-value]\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.t3.process_T3","title":"<code>pyintegrity.pulseecho.processing.t3.process_T3(series, interval_f=None, limits_windows=None, fft_scale=None)</code>","text":"<p>Derive pipe thickness and impedance based on the T3 algorithm</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <code>interval_f</code> <code>tuple[float, float] | None</code> <p>limits for frequency search window from expected resonance frequency in Hz, default (-60000.,60000.)</p> <code>None</code> <code>limits_windows</code> <code>tuple[float, float] | None</code> <p>give the window size in periods for the normalisation window (symmetric) and the end of the             signal window from max amplitude. Default= (2.5,7)</p> <code>None</code> <code>fft_scale</code> <code>int | None</code> <p>value to scale fft resolution, default value = 10</p> <code>None</code> <p>Returns:</p> Name Type Description <code>T3result</code> <code>T3result</code> <p>object containing impedance and thickness</p> Source code in <code>src/pyintegrity/pulseecho/processing/t3.py</code> <pre><code>def process_T3(series: PulseEchoSeries,\n               interval_f: tuple[float, float] | None = None,\n               limits_windows: tuple[float, float] | None = None,\n               fft_scale: int | None = None)-&gt; T3result:\n    \"\"\"Derive pipe thickness and impedance based on the T3 algorithm\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n        interval_f: limits for frequency search window from expected resonance frequency in Hz, default (-60000.,60000.)\n        limits_windows: give the window size in periods for the normalisation window (symmetric) and the end of the \\\n            signal window from max amplitude. Default= (2.5,7)\n        fft_scale: value to scale fft resolution, default value = 10\n\n    Returns:\n        T3result: object containing impedance and thickness\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None and series.casing.material.speed is not None\n    assert series.casing.thickness_nominal is not None\n\n    # Frequency interval\n    if interval_f is None:\n        f_search=(-60000.,60000.)\n    elif isinstance(interval_f, (list, tuple)):\n        if len(interval_f)!=2:\n            print('The search interval needs to be given as start and stop frequency deviation from the expected ' \n                  'resonance frequency in Hz. The default range [-60000, 60000] will be used. ')\n            f_search=(-60000.,60000.)\n        else:\n            f_search=interval_f \n    else:\n        print('The search interval needs to be a tuple or a list with two values. The default range [-60000, 60000] '\n              'will be used. ')\n        f_search=(-60000.,60000.)\n\n    # Window length normalization window, processing window   \n    if limits_windows is None:\n        lim_win=(2.5,7.)\n    elif isinstance(limits_windows, (list, tuple)):\n        if len(limits_windows)!=2:\n            print('Window length for normalization and signal window, two values should be given. The default window '\n                  'length of 2.5 and 7 periods will be used.')\n            lim_win=(2.5,7.)\n        else:\n            lim_win=limits_windows \n    else:\n        print('Window length for normalization and signal window, two values should be given. The default window '\n              'length of 2.5 and 7 periods will be used.')\n        lim_win=(2.5,7.)    \n\n    # Scaling for fft resolution\n    if fft_scale is None:\n        scale=10\n    else:\n        scale=fft_scale\n\n    f_exp= series.casing.material.speed/(2*series.casing.thickness_nominal)\n\n    # Preprocessing of data\n    T3freq,T3taugSN_meas, T3N, indT_S0, indT_S1, indT_N0, indT_N1=PreStep_processing(series,lim_win,scale)\n\n    # Group delay minimum, group delay bandwidth and resonance frequency from group-delay curve\n    fres_meas,taumin_meas=T3_tauF_tauMin(T3freq, f_exp, f_search, T3taugSN_meas)\n    T3band_meas=T3_band(T3freq, fres_meas,taumin_meas, T3taugSN_meas)\n\n\n    Spec_firstpulse = LogChannel(T3N, z=series.z, phi=series.phi , f=T3freq)          \n    fres = LogChannel(fres_meas, z=series.z, phi=series.phi)\n    band = LogChannel(T3band_meas, z=series.z, phi=series.phi)\n    result = T3result(band,fres,Spec_firstpulse)\n\n    # derive thickness and impedance\n    if fres is None:    # No resonance frequency detected\n        return result   # calculation cannot proceed further\n    if band is None:    # no bandwidth detected\n        print('Thickness is calculated from resonance frequency of group delay minimum. '\n              'No optimization algorithm used.')\n        result.calculate_thickness_fres(series)\n        return result\n    result.derive_impedance_thickness(series, T3band_meas, T3freq, f_search, indT_S0, indT_S1, indT_N0, indT_N1)\n\n    return result\n</code></pre>"},{"location":"api-pulseecho-processing/#abcd-algorithm","title":"ABCD algorithm","text":"<p>Module for ABCD processing following the description in Mandal (2000) The algorithm is based on the derivation of the parameter Sw, the sum of the  absolute value over the ringdown period.</p> <p>The 1D plane wave model as given by Mandal has a 180-degree phase shift  compared to reference solutions. This does not make a difference in context of  this method as only the absolute values of the modelled waveform are used in  the end. However, to have a correct result we changed this.</p> <p>In Mandal the ABCD function is derived by combining the spectrum of multiple measurements, here we use the spectrum of each of the measurements</p> <p>Mandal, B., Standley, T.E., 2000. Method to determine self-calibrated  circumferential cased bond impedance. US Patent 6,041,861.</p>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.ABCDresult","title":"<code>pyintegrity.pulseecho.processing.abcd.ABCDresult</code>","text":"<p>             Bases: <code>ProcessingResult</code></p> <p>Result container for ABCD processing</p> <p>Parameters:</p> Name Type Description Default <code>fres</code> <code>LogChannel</code> <p>resonance frequency to derive thickness</p> required <code>Sw</code> <code>LogChannel</code> <p>the parameter Sw as defined in Mandal et al. (2000) derived from the measurement data</p> required <code>Spec_firstpulse</code> <code>LogChannel</code> <p>the spectrum from the first pulse used in the convolution with the 1D model</p> required Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>class ABCDresult(ProcessingResult):\n    \"\"\"Result container for ABCD processing\n\n    Args:\n        fres: resonance frequency to derive thickness\n        Sw: the parameter Sw as defined in Mandal et al. (2000) derived from the measurement data\n        Spec_firstpulse: the spectrum from the first pulse used in the convolution with the 1D model\n    \"\"\"\n    def __init__(self, Sw: LogChannel,\n                 fres: LogChannel,\n                 Spec_firstpulse: LogChannel) -&gt; None: \n        super().__init__()                          # Initializes impedance behind casing and casing thickness\n\n        self.Sw= Sw\n        self.fres= fres\n        self.Spec_firstpulse= Spec_firstpulse\n        self.thickness: LogChannel\n\n    def calculate_thickness(self,series: PulseEchoSeries) -&gt; None:\n        \"\"\"Calculate thickness from resonance frequency\n\n        Args:\n            series: `PulseEchoSeries` object containing the waveform data\n        \"\"\"\n        assert series.casing is not None and series.casing.material is not None \\\n            and series.casing.material.speed is not None\n        d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n        self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n\n    def calculate_impedance(self,series: PulseEchoSeries) -&gt; None:\n        \"\"\"Calculate impedance \n\n        Args: series: `PulseEchoSeries` object containing the waveform data\n        \"\"\"\n        Z=_ABCD_Z(series,self.Spec_firstpulse.data.to_numpy(),self.thickness.data.data,self.Sw.data.to_numpy())\n        self.impedance = LogChannel(Z, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.ABCDresult.calculate_impedance","title":"<code>calculate_impedance(series)</code>","text":"<p>Calculate impedance </p> <p>Args: series: <code>PulseEchoSeries</code> object containing the waveform data</p> Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>def calculate_impedance(self,series: PulseEchoSeries) -&gt; None:\n    \"\"\"Calculate impedance \n\n    Args: series: `PulseEchoSeries` object containing the waveform data\n    \"\"\"\n    Z=_ABCD_Z(series,self.Spec_firstpulse.data.to_numpy(),self.thickness.data.data,self.Sw.data.to_numpy())\n    self.impedance = LogChannel(Z, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.ABCDresult.calculate_thickness","title":"<code>calculate_thickness(series)</code>","text":"<p>Calculate thickness from resonance frequency</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>def calculate_thickness(self,series: PulseEchoSeries) -&gt; None:\n    \"\"\"Calculate thickness from resonance frequency\n\n    Args:\n        series: `PulseEchoSeries` object containing the waveform data\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.material.speed is not None\n    d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n    self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.Mandal_plane_wave","title":"<code>pyintegrity.pulseecho.processing.abcd.Mandal_plane_wave(ZfoH, Ct, iim, cim, cvp, Hafreq, R)</code>","text":"<p>1 D model as described  in Madal however *-1 (Mandal result has a 180 degree phase shift) </p> <p>Parameters:</p> Name Type Description Default <code>ZfoH</code> <code>int</code> <p>the guess for the impedance behind the pipe</p> required <code>Ct</code> <code>float</code> <p>the guess for the thickness</p> required <code>iim</code> <code>float</code> <p>the impedance of the fluid inside the pipe</p> required <code>cim</code> <code>float</code> <p>the impedance of the casing/pipe</p> required <code>cvp</code> <code>float</code> <p>speed of the casing</p> required <code>Hafreq</code> <code>ndarray</code> <p>the frequency vector.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>ndarray</code> <p>Transformation function</p> Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>@guvectorize([(int64, float64, float32, float64, float64,float64[:],complex128[:])], '(),(),(),(),(),(n)-&gt;(n)', \\\n              nopython=True, target='parallel')           \ndef Mandal_plane_wave(ZfoH: int, Ct:float, iim:float, cim:float, cvp:float, Hafreq: np.ndarray, R: np.ndarray):\n    \"\"\" 1 D model as described  in Madal however *-1 (Mandal result has a 180 degree phase shift) \n\n    Args:\n        ZfoH: the guess for the impedance behind the pipe\n        Ct: the guess for the thickness\n        iim: the impedance of the fluid inside the pipe\n        cim: the impedance of the casing/pipe\n        cvp: speed of the casing\n        Hafreq: the frequency vector.\n\n    Returns:\n        R (np.ndarray): Transformation function\n    \"\"\"\n    R[:] = (cim-iim)/(iim+cim) \\\n        - ( (((4*iim*cim)/((iim+cim)**2))*((cim-ZfoH)/(cim+ZfoH))) \\\n           / (1-(((cim-iim)/(iim+cim))*((cim-ZfoH)/(cim+ZfoH))*np.exp(-1j*2*2*np.pi*Hafreq[:]*Ct/cvp))) \\\n           * np.exp(-1j*2*2*np.pi*Hafreq[:]*Ct/cvp))\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.Mandal_processing","title":"<code>pyintegrity.pulseecho.processing.abcd.Mandal_processing(series)</code>","text":"<p>Processing of data following description in Mandal</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <p>Returns:</p> Name Type Description <code>f_ha</code> <code>Quantity</code> <p>resonance frequency</p> <code>S_w_orig</code> <code>ndarray</code> <p>Sw parameter derived from waveform data</p> <code>S_Ha</code> <code>ndarray</code> <p>Spectrum of the first pulse used in the convolution with the plane wave model result</p> <code>Hafreq</code> <code>Quantity</code> <p>Frequency vector corresponding to the spectrum</p> Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>def Mandal_processing(series: PulseEchoSeries) -&gt; tuple[Quantity, np.ndarray, np.ndarray, Quantity]:\n    \"\"\" Processing of data following description in Mandal\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n\n    Returns:\n        f_ha: resonance frequency\n        S_w_orig: Sw parameter derived from waveform data\n        S_Ha: Spectrum of the first pulse used in the convolution with the plane wave model result\n        Hafreq: Frequency vector corresponding to the spectrum \n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None and series.casing.material.speed is not None\n    assert series.casing.thickness_nominal is not None\n\n    dt = 1/series.sampling_freq\n    f_exp = series.casing.material.speed/(2*series.casing.thickness_nominal)\n    waveforms = series.data.to_numpy()\n    t = series.data.t.to_numpy()\n    [M,N,Nfft]=waveforms.shape\n    Nfft2=int(Nfft/2)\n    Hafreq=np.arange(0,Nfft)/Nfft/((dt))\n\n    # Fine time of maximum of first reflection\n    T_peak = _find_reflection(waveforms,f_exp.magnitude,t[0],dt.magnitude,axis=2)   # pylint: disable=typecheck\n\n    t_fit = (T_peak+2/f_exp.magnitude,T_peak+7/f_exp.magnitude)\n    tstart = np.argmin(np.abs(t[np.newaxis, np.newaxis, :]-t_fit[0][:, :, np.newaxis]),axis=2)\n    tstop =  np.argmin(np.abs(t[np.newaxis, np.newaxis, :]-t_fit[1][:, :, np.newaxis]),axis=2)\n\n    # Derive Sw parameter, normalized\n    S_w_orig=_get_Sw(waveforms,tstart,tstop)   # pylint: disable=typecheck\n\n    # Get resonance frequency\n    Ha_Rwin_dB = _res_Spec(tstart,tstop,Nfft,waveforms)   # pylint: disable=typecheck\n    f_ha,_ = find_peak(Hafreq[0:Nfft2],Ha_Rwin_dB[:,:,0:Nfft2])   # pylint: disable=unsubscriptable-object\n    assert isinstance(f_ha, Quantity)\n\n    # Derive spectrum of the first reflection        \n    t_fitF = (T_peak-2/f_ha.magnitude, T_peak+2/f_ha.magnitude)\n    tfstart = np.argmin(np.abs(t[np.newaxis, np.newaxis, :]-t_fitF[0][:, :, np.newaxis]),axis=2)\n    tfstop =  np.argmin(np.abs(t[np.newaxis, np.newaxis, :]-t_fitF[1][:, :, np.newaxis]),axis=2)\n\n    #Upscaling \n    NfftS=Nfft*10\n    waveformsScale=np.zeros([M,N,NfftS])\n    waveformsScale[:,:,0:Nfft]=waveforms\n    S_Ha = _tukey_Spec(tfstart, tfstop, NfftS, waveformsScale)   # pylint: disable=typecheck\n    SHafreq=np.arange(0,NfftS)/NfftS/((dt))\n\n\n    return f_ha, S_w_orig, S_Ha, SHafreq\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.abcd.process_abcd","title":"<code>pyintegrity.pulseecho.processing.abcd.process_abcd(series)</code>","text":"<p>Derive pipe thickness and impedance based on the abcd algorithm</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <p>Returns:</p> Type Description <code>ABCDresult</code> <p>ABCDResult object containing impedance and thickness</p> Source code in <code>src/pyintegrity/pulseecho/processing/abcd.py</code> <pre><code>def process_abcd(series: PulseEchoSeries)-&gt; ABCDresult:\n    \"\"\"Derive pipe thickness and impedance based on the abcd algorithm\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n\n    Returns:\n        ABCDResult object containing impedance and thickness\n    \"\"\"\n    f_resonance, Sw_arr, Spec_firstpulse_arr, fvec = Mandal_processing(series)  \n    Sw= LogChannel(Sw_arr, z=series.z, phi=series.phi)\n    fres = LogChannel(f_resonance, z=series.z, phi=series.phi)\n    Spec_firstpulse = LogChannel(Spec_firstpulse_arr, z=series.z, phi=series.phi , f=fvec)\n    result = ABCDresult(Sw,fres,Spec_firstpulse)\n\n\n    # Calculate thickness and impedance\n    if fres is None:    # No resonance frequency detected\n        return result   # calculation cannot proceed further\n    result.calculate_thickness(series)\n    result.calculate_impedance(series)\n\n    return result\n</code></pre>"},{"location":"api-pulseecho-processing/#l1-algorithm","title":"L1 algorithm","text":"<p>Module for L1 processing following the description in Tello (2010). The description in the patent is partly vague. We use the gradient of the ringdown to determine the impedance through the optimization algorithm.</p> <p>Tello, L.N., 2010. Ultrasonic logging methods and apparatus for automatically calibrating measures of acoustic impedance of cement and other materials behind casing. US Patent No. US 7,755,973 B2</p>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1result","title":"<code>pyintegrity.pulseecho.processing.l1.L1result</code>","text":"<p>             Bases: <code>ProcessingResult</code></p> <p>Result container for L1 processing</p> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>LogChannel</code> <p>gradient of ringdown tail</p> required <code>fres</code> <code>LogChannel</code> <p>resonance frequency derived from group-delay minimum</p> required <code>Spec_firstpulse</code> <code>LogChannel</code> <p>the spectrum from the first pulse used in the convolution with the 1D model</p> required Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>class L1result(ProcessingResult):\n    \"\"\"Result container for L1 processing\n\n    Args:\n        L1: gradient of ringdown tail\n        fres: resonance frequency derived from group-delay minimum\n        Spec_firstpulse: the spectrum from the first pulse used in the convolution with the 1D model\n    \"\"\"\n    def __init__(self, L1: LogChannel,\n                    fres: LogChannel,\n                    Spec_firstpulse: LogChannel) -&gt; None: \n        super().__init__()                         \n\n        self.L1= L1\n        self.fres= fres\n        self.Spec_firstpulse= Spec_firstpulse\n        self.thickness: LogChannel\n\n    def calculate_thickness(self,series: PulseEchoSeries) -&gt; None:\n        \"\"\"Calculate thickness from resonance frequency\n\n        Args: \n            series: `PulseEchoSeries` object containing the waveform data\n        \"\"\"\n        assert series.casing is not None and series.casing.material is not None \\\n            and series.casing.material.speed is not None\n        d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n        self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n\n    def derive_impedance(self,series: PulseEchoSeries,\n                         Trt: np.ndarray,\n                         freq: Quantity,\n                         win_lim: list) -&gt; None:\n        \"\"\"Derive impedance using the L1 gradient value through optimization algorithm \n\n        Args: \n            series: `PulseEchoSeries` object containing the waveform data\n            Trt: transfer function, spectrum of initial pulse\n            freq: frequency vector\n            win_lim: window limits for calculation of ringdown gradient\n        \"\"\"\n        dt = 1/series.sampling_freq\n\n        L1data = self.L1.data.to_numpy()\n        d = self.thickness.data.to_numpy()\n        [M,N] = L1data.shape\n\n        assert series.casing is not None and series.casing.material is not None and series.inner_material is not None\n        casing_material = series.casing.material\n        inner_material = series.inner_material\n        assert casing_material.speed is not None and casing_material.impedance is not None\n        assert inner_material.impedance is not None\n\n        Z_res=np.zeros([M,N])\n        initial_val =5*10**6\n        for i in prange(M):   # pylint: disable=not-an-iterable\n            for j in prange(N):   # pylint: disable=not-an-iterable\n                if ~np.isnan(d[i,j]):\n                    argsH=(freq.magnitude,\n                           casing_material.speed.magnitude,\n                           d[i,j],\n                           casing_material.impedance.magnitude,\n                           inner_material.impedance.magnitude[i],\n                           dt.magnitude,\n                           Trt[i,j,:],\n                           L1data[i,j],\n                           win_lim[0][i,j],\n                           win_lim[1][i,j])\n                    try:\n                        final_L2 = minimize(L1_optimize, initial_val, args=argsH,method='Nelder-Mead',tol=1000)\n                        Z_res[i,j]=final_L2.x*10**-6\n                    except:   # FIXME: Specify exception type   # pylint: disable=bare-except\n                        Z_res[i,j]=np.nan\n                else:\n                    Z_res[i,j]=np.nan\n\n        self.impedance = LogChannel(Quantity(Z_res,'MRayl'), z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1result.calculate_thickness","title":"<code>calculate_thickness(series)</code>","text":"<p>Calculate thickness from resonance frequency</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def calculate_thickness(self,series: PulseEchoSeries) -&gt; None:\n    \"\"\"Calculate thickness from resonance frequency\n\n    Args: \n        series: `PulseEchoSeries` object containing the waveform data\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.material.speed is not None\n    d=Quantity((series.casing.material.speed.magnitude/(2*self.fres.data.to_numpy())),'m')\n    self.thickness= LogChannel(d, z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1result.derive_impedance","title":"<code>derive_impedance(series, Trt, freq, win_lim)</code>","text":"<p>Derive impedance using the L1 gradient value through optimization algorithm </p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> object containing the waveform data</p> required <code>Trt</code> <code>ndarray</code> <p>transfer function, spectrum of initial pulse</p> required <code>freq</code> <code>Quantity</code> <p>frequency vector</p> required <code>win_lim</code> <code>list</code> <p>window limits for calculation of ringdown gradient</p> required Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def derive_impedance(self,series: PulseEchoSeries,\n                     Trt: np.ndarray,\n                     freq: Quantity,\n                     win_lim: list) -&gt; None:\n    \"\"\"Derive impedance using the L1 gradient value through optimization algorithm \n\n    Args: \n        series: `PulseEchoSeries` object containing the waveform data\n        Trt: transfer function, spectrum of initial pulse\n        freq: frequency vector\n        win_lim: window limits for calculation of ringdown gradient\n    \"\"\"\n    dt = 1/series.sampling_freq\n\n    L1data = self.L1.data.to_numpy()\n    d = self.thickness.data.to_numpy()\n    [M,N] = L1data.shape\n\n    assert series.casing is not None and series.casing.material is not None and series.inner_material is not None\n    casing_material = series.casing.material\n    inner_material = series.inner_material\n    assert casing_material.speed is not None and casing_material.impedance is not None\n    assert inner_material.impedance is not None\n\n    Z_res=np.zeros([M,N])\n    initial_val =5*10**6\n    for i in prange(M):   # pylint: disable=not-an-iterable\n        for j in prange(N):   # pylint: disable=not-an-iterable\n            if ~np.isnan(d[i,j]):\n                argsH=(freq.magnitude,\n                       casing_material.speed.magnitude,\n                       d[i,j],\n                       casing_material.impedance.magnitude,\n                       inner_material.impedance.magnitude[i],\n                       dt.magnitude,\n                       Trt[i,j,:],\n                       L1data[i,j],\n                       win_lim[0][i,j],\n                       win_lim[1][i,j])\n                try:\n                    final_L2 = minimize(L1_optimize, initial_val, args=argsH,method='Nelder-Mead',tol=1000)\n                    Z_res[i,j]=final_L2.x*10**-6\n                except:   # FIXME: Specify exception type   # pylint: disable=bare-except\n                    Z_res[i,j]=np.nan\n            else:\n                Z_res[i,j]=np.nan\n\n    self.impedance = LogChannel(Quantity(Z_res,'MRayl'), z=series.z, phi=series.phi)\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1_model","title":"<code>pyintegrity.pulseecho.processing.l1.L1_model(freqW, vpCAS, Tcas, Z_cas, Zin, Zout, Trt)</code>","text":"<p>Calculation of modelled envelope based on the plane wave model</p> <p>Parameters:</p> Name Type Description Default <code>freqW</code> <code>ndarray</code> <p>frequency vector </p> required <code>vpCAS</code> <code>float</code> <p>P-wave speed of casing</p> required <code>Tcas</code> <code>float</code> <p>derived thickness of casing</p> required <code>Z_cas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner fluid</p> required <code>Zout</code> <code>float</code> <p>assumption of outer-material impedance</p> required <p>Returns:</p> Name Type Description <code>env</code> <code>ndarray</code> <p>envelope derived  from modelled reflection coefficient</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def L1_model(freqW: np.ndarray, vpCAS: float, Tcas: float, Z_cas: float, Zin: float, Zout: float, Trt: np.ndarray\n             ) -&gt; np.ndarray: \n    \"\"\" Calculation of modelled envelope based on the plane wave model\n\n    Args:\n        freqW: frequency vector \n        vpCAS: P-wave speed of casing\n        Tcas: derived thickness of casing\n        Z_cas: impedance of casing\n        Zin: impedance of inner fluid\n        Zout: assumption of outer-material impedance\n\n    Returns:\n        env: envelope derived  from modelled reflection coefficient\n    \"\"\"\n    Tr = L1_planewave(freqW,vpCAS,Tcas,Z_cas,Zin,Zout)\n    Nfft=len(Tr)\n    data_conv=Tr*Trt\n    data_mod=np.real(ifft(data_conv[:int(Nfft/2)]*2,Nfft))\n    env = np.abs(hilbert(data_mod))\n    env= 20*np.log10(env)\n    return env\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1_optimize","title":"<code>pyintegrity.pulseecho.processing.l1.L1_optimize(in_val, freqW, vpCAS, Tcas, Z_cas, Zin, dt, Trt, L1data, indTS, indTE)</code>","text":"<p>Algorithm that calls model to optimize error between real data and model data to find the best impedance estimate</p> <p>Parameters:</p> Name Type Description Default <code>in_val</code> <code>float</code> <p>input value of impedance in MRayl</p> required <code>freqW</code> <code>ndarray</code> <p>frequency vector </p> required <code>vpCAS</code> <code>float</code> <p>P-wave speed of casing</p> required <code>Tcas</code> <code>float</code> <p>derived thickness of casing</p> required <code>Z_cas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner fluid</p> required <code>dt</code> <code>float</code> <p>time increment</p> required <code>Trt</code> <code>ndarray</code> <p>transfer function, spectrum of initial reflection</p> required <code>L1data</code> <code>float</code> <p>reverberation  gradient from data </p> required <code>indTS</code> <code>int</code> <p>start for window to derive L1 gradient </p> required <code>indTE</code> <code>int</code> <p>stop for window to derive L1 gradient </p> required <p>Returns:</p> Type Description <code>float</code> <p>error between gradient of measured and modelled data</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def L1_optimize(in_val: float, freqW: np.ndarray, vpCAS: float, Tcas: float, Z_cas: float, Zin: float, dt: float,\n                Trt: np.ndarray, L1data: float, indTS: int, indTE: int) -&gt; float:\n    \"\"\"Algorithm that calls model to optimize error between real data and model data to find the best impedance estimate\n\n    Args:\n        in_val: input value of impedance in MRayl\n        freqW: frequency vector \n        vpCAS: P-wave speed of casing\n        Tcas: derived thickness of casing\n        Z_cas: impedance of casing\n        Zin: impedance of inner fluid\n        dt: time increment\n        Trt: transfer function, spectrum of initial reflection\n        L1data: reverberation  gradient from data \n        indTS: start for window to derive L1 gradient \n        indTE: stop for window to derive L1 gradient \n\n    Returns:\n        error between gradient of measured and modelled data\n    \"\"\"\n    in_val=in_val*10**-6\n\n    data_modW = L1_model(freqW,vpCAS,Tcas,Z_cas,Zin,in_val,Trt)\n    L1mod=_L1_gradient1(data_modW,dt,indTS,indTE)\n    return (L1mod-L1data)**2\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1_planewave","title":"<code>pyintegrity.pulseecho.processing.l1.L1_planewave(freqW, vpCAS, Tcas, Z_cas, Zin, Zout)</code>","text":"<p>Plane wave calculation using derived thickness and assumption for outer-material impedance</p> <p>Parameters:</p> Name Type Description Default <code>freqW</code> <code>ndarray</code> <p>frequency vector </p> required <code>vpCAS</code> <code>float</code> <p>P-wave speed of casing</p> required <code>Tcas</code> <code>float</code> <p>derived thickness of casing</p> required <code>Z_cas</code> <code>float</code> <p>impedance of casing</p> required <code>Zin</code> <code>float</code> <p>impedance of inner fluid</p> required <code>Zout</code> <code>float</code> <p>assumption of outer-material impedance</p> required <p>Returns:</p> Name Type Description <code>Tr</code> <code>ndarray</code> <p>reflection coefficient form plane wave model</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>@njit\ndef L1_planewave(freqW: np.ndarray, vpCAS: float, Tcas: float, Z_cas: float, Zin: float, Zout: float) -&gt; np.ndarray:\n    \"\"\" Plane wave calculation using derived thickness and assumption for\n    outer-material impedance\n\n    Args:\n        freqW: frequency vector \n        vpCAS: P-wave speed of casing\n        Tcas: derived thickness of casing\n        Z_cas: impedance of casing\n        Zin: impedance of inner fluid\n        Zout: assumption of outer-material impedance\n\n    Returns:\n        Tr: reflection coefficient form plane wave model\n    \"\"\"\n    beta = 2* np.pi*freqW/vpCAS\n    A = np.cos(beta*Tcas)  \n    B = -Z_cas*1j*np.sin(beta*Tcas)\n    C= -1/Z_cas*1j*np.sin(beta*Tcas)\n    D = np.cos(beta*Tcas) \n    Tr = (A*Zin-D*Zout-C*Zin*Zout+B)/(C*Zin*Zout-D*Zout-A*Zin+B) \n    return Tr\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.L1_preprocessing","title":"<code>pyintegrity.pulseecho.processing.l1.L1_preprocessing(series, wlim, scale)</code>","text":"<p>Preprocessing of the data to derive group delay curve, resonance frequency, group delay minimum and bandwidth         of minimum</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <code>wlim</code> <code>tuple[float, float, float]</code> <p>limits for windows as periods from max amplitude, first value symmetric to derive first pulse, 2. and             3. value start and stop to derive L1 gradient</p> required <code>scale</code> <code>int</code> <p>scaling factor for higher resolution for frequency resolution</p> required <p>Returns:</p> Name Type Description <code>TrO</code> <code>ndarray</code> <p>transfer function, spectrum of entire pulse</p> <code>Trt</code> <code>ndarray</code> <p>transfer function, spectrum of initial pulse</p> <code>freqW</code> <code>Quantity</code> <p>frequency vector</p> <code>env</code> <code>ndarray</code> <p>envelope of signals</p> <code>list</code> <p>[indT2,indT3]: window limits for calculation of ringdown gradient</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def L1_preprocessing(series: PulseEchoSeries,\n                     wlim: tuple[float, float, float],\n                     scale: int) -&gt; tuple[np.ndarray, np.ndarray, Quantity, np.ndarray, list]:\n    \"\"\" Preprocessing of the data to derive group delay curve, resonance frequency, group delay minimum and bandwidth \\\n        of minimum\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n        wlim: limits for windows as periods from max amplitude, first value symmetric to derive first pulse, 2. and \\\n            3. value start and stop to derive L1 gradient\n        scale: scaling factor for higher resolution for frequency resolution\n\n    Returns:\n        TrO: transfer function, spectrum of entire pulse\n        Trt: transfer function, spectrum of initial pulse\n        freqW: frequency vector\n        env: envelope of signals\n        [indT2,indT3]: window limits for calculation of ringdown gradient\n    \"\"\"\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.material.speed is not None and series.casing.thickness_nominal is not None\n\n    dt = 1/series.sampling_freq\n    f_exp = series.casing.material.speed/(2*series.casing.thickness_nominal)\n    waveforms = series.data.to_numpy()\n    t: np.ndarray = series.data.t.to_numpy()\n    env: np.ndarray = np.abs(hilbert(waveforms))\n    env= 20*np.log10(env)\n    t_max,_ = find_peak(t,env)\n    [M,N,Nfft]=waveforms.shape\n\n    # Find sample number for window\n    t_W=[t_max-1/f_exp.magnitude*wlim[0],\n         t_max+1/f_exp.magnitude*wlim[0],\n         t_max+1/f_exp.magnitude*wlim[1],\n         t_max+1/f_exp.magnitude*wlim[2]]\n    t = t[np.newaxis,np.newaxis,:]\n    indT0 = np.argmin(np.abs(t - t_W[0][:,:,np.newaxis]),axis=-1)   # First sample index of the range\n    indT1 = np.argmin(np.abs(t - t_W[1][:,:,np.newaxis]),axis=-1)   # second sample index of the range\n    indT2 = np.argmin(np.abs(t - t_W[2][:,:,np.newaxis]),axis=-1)   # third sample index of the range\n    indT3 = np.argmin(np.abs(t - t_W[3][:,:,np.newaxis]),axis=-1)   # third sample index of the range\n\n    # Windowed data\n    NfftS=Nfft*scale\n    waveformsScale=np.zeros([M,N,NfftS])\n    waveformsScale[:,:,0:Nfft]=waveforms\n\n    Trt=_tukey_Spec(indT0,indT1,NfftS,waveformsScale)  # initial pulse for 1D plane wave model #pylint: disable=typecheck\n    TrO=_tukey_Spec(indT0,indT3,NfftS,waveformsScale)  # to derive thickness    #pylint: disable=typecheck\n\n    freqW=np.arange(0,NfftS)/NfftS/((dt))\n\n    return TrO, Trt, freqW, env, [indT2,indT3]\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.find_resonance","title":"<code>pyintegrity.pulseecho.processing.l1.find_resonance(TrO, f, f_exp, fW)</code>","text":"<p>Derive resonance frequency from spectrum from entire signal</p> <p>Parameters:</p> Name Type Description Default <code>TrO</code> <code>ndarray</code> <p>transfer function, spectrum of entire pulse</p> required <code>f</code> <code>Quantity</code> <p>frequency vector</p> required <code>f_exp</code> <code>Quantity</code> <p>expected resonance frequency from nominal thickness</p> required <code>fW</code> <code>tuple[float, float]</code> <p>Search window size plus/minus</p> required <p>Returns:</p> Name Type Description <code>fres</code> <code>Quantity</code> <p>resonance frequency</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def find_resonance(TrO: np.ndarray, f: Quantity, f_exp: Quantity, fW: tuple[float, float]) -&gt; Quantity:\n    \"\"\" Derive resonance frequency from spectrum from entire signal\n\n    Args:\n        TrO: transfer function, spectrum of entire pulse\n        f: frequency vector\n        f_exp: expected resonance frequency from nominal thickness\n        fW: Search window size plus/minus\n\n    Returns:\n        fres: resonance frequency\n    \"\"\"\n    indf0 = np.argmin(np.abs(f.magnitude - (f_exp.magnitude+fW[0])))  # First sample index of the range\n    indf1 = np.argmin(np.abs(f.magnitude - (f_exp.magnitude+fW[1])))\n\n    fres,_=find_peak(f[indf0:indf1],-20*np.real(np.log10(TrO[:,:,indf0:indf1])))\n    assert isinstance(fres, Quantity)\n    return fres\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.hilbert1","title":"<code>pyintegrity.pulseecho.processing.l1.hilbert1(u)</code>","text":"<p>implementation of Hilbert transform for usage with numba</p>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.hilbert1--httpsstackoverflowcomquestions56380536hilbert-transform-in-python","title":"https://stackoverflow.com/questions/56380536/hilbert-transform-in-python","text":"<p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>input signal</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>ndarray</code> <p>derived Hilbert transform</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>@njit\ndef hilbert1(u: np.ndarray) -&gt; np.ndarray:\n    \"\"\" implementation of Hilbert transform for usage with numba\n    # https://stackoverflow.com/questions/56380536/hilbert-transform-in-python\n\n    Args:\n        u: input signal\n\n    Returns:\n        v: derived Hilbert transform\n    \"\"\"\n    N = len(u)\n    # take forward Fourier transform\n    U: np.ndarray = fft(u)\n    M = N - N//2 - 1\n    # zero out negative frequency components\n    U[N//2+1:] = np.array([0] * M)   # pylint: disable=unsupported-assignment-operation\n    # double fft energy except @ DC0\n    U[1:N//2] = np.array(2 * U[1:N//2])   # pylint: disable=unsupported-assignment-operation\n    # take inverse Fourier transform\n    v = ifft(U)\n    return v\n</code></pre>"},{"location":"api-pulseecho-processing/#pyintegrity.pulseecho.processing.l1.process_L1","title":"<code>pyintegrity.pulseecho.processing.l1.process_L1(series, interval_f=None, limits_windows=None, fft_scale=None)</code>","text":"<p>Derive pipe thickness and impedance based on the L1 algorithm</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>PulseEchoSeries</code> <p><code>PulseEchoSeries</code> containing input waveform data</p> required <code>interval_f</code> <code>tuple[float, float] | None</code> <p>limits for frequency search window from expected resonance frequency in Hz, default (-40000,40000)</p> <code>None</code> <code>limits_windows</code> <code>tuple[float, float, float] | None</code> <p>define window size as number of periods from maximum amplitude for the window defining the             initial pulse (symmetric) and the window to derive the L1 parameter, default (1.5,3,9)</p> <code>None</code> <code>fft_scale</code> <code>int | None</code> <p>scaling factor for higher frequency resolution</p> <code>None</code> <p>Returns:</p> Name Type Description <code>L1Result</code> <code>L1result</code> <p>object containing impedance and thickness</p> Source code in <code>src/pyintegrity/pulseecho/processing/l1.py</code> <pre><code>def process_L1(series: PulseEchoSeries,\n               interval_f: tuple[float, float] | None = None,\n               limits_windows: tuple[float, float, float] | None = None,\n               fft_scale: int | None = None)-&gt; L1result:\n    \"\"\"Derive pipe thickness and impedance based on the L1 algorithm\n\n    Args:\n        series: `PulseEchoSeries` containing input waveform data\n        interval_f: limits for frequency search window from expected resonance frequency in Hz, default (-40000,40000)\n        limits_windows: define window size as number of periods from maximum amplitude for the window defining the \\\n            initial pulse (symmetric) and the window to derive the L1 parameter, default (1.5,3,9)\n        fft_scale: scaling factor for higher frequency resolution\n\n    Returns:\n        L1Result: object containing impedance and thickness\n    \"\"\"   \n    # Frequency interval\n    if interval_f is None:\n        f_search=(-40000.,40000.)\n    elif isinstance(interval_f, (list, tuple)):\n        if len(interval_f)!=2:\n            print('The search interval needs to be given as start and stop frequency deviation from the expected '\n                  'resonance frequency in Hz. The default range [-40000, 40000] will be used.')\n            f_search=(-40000.,40000.)\n        else:\n            f_search=interval_f \n    else:\n        print('The search interval needs to be a tuple or a list with two values. The default range [-40000, 40000] '\n              'will be used.')\n        f_search=(-40000,40000)   \n\n     # Window length normalization window, processing window   \n    if limits_windows is None:\n        lim_win=(1.5, 3., 9.)\n    elif isinstance(limits_windows, (list, tuple)):\n        if len(limits_windows)!=3:\n            print('Start and stop limits for the windows, 3 values as number of periods from the max pulse amplitude '\n                  'should be given. Symmetric value for the window defining the first pulse, and start and stop of the '\n                  'window for the L1 calculation. Default used (1.5,3,9)')\n            lim_win=(1.5, 3., 9.)\n        else:\n            lim_win=limits_windows \n    else:\n        print('Start and stop limits for the windows, 3 values as number of periods from the max pulse amplitude '\n              'should be given. Symmetric value for the window defining the first pulse, and start and stop of the '\n              'window for the L1 calculation. Default used (1.5,3,9)')\n        lim_win=(1.5, 3., 9.)    \n\n     # Scaling for fft resolution\n    if fft_scale is None:\n        scale=10\n    else:\n        scale=fft_scale\n\n    TrO, Trt, freq, env, win_lim = L1_preprocessing(series,lim_win,scale)    \n    Spec_firstpulse = LogChannel(Trt, z=series.z, phi=series.phi , f=freq)\n\n    assert series.casing is not None and series.casing.material is not None \\\n        and series.casing.thickness_nominal is not None\n    f_exp = series.casing.material.speed/(2*series.casing.thickness_nominal)\n    f_resonance=find_resonance(TrO,freq,f_exp,f_search)\n    fres = LogChannel(f_resonance, z=series.z, phi=series.phi)\n\n    dt = 1/series.sampling_freq\n    L1data=_L1_gradient(env,dt.magnitude,win_lim[0],win_lim[1])   #pylint: disable=typecheck\n    L1 = LogChannel(L1data, z=series.z, phi=series.phi)\n\n    result=L1result(L1,fres,Spec_firstpulse)\n\n    # Calculate thickness\n    if fres is None:    # No resonance frequency detected\n        return result   # calculation cannot proceed further\n    result.calculate_thickness(series)\n\n    if L1 is None:      # No L1 gradient derived\n        return result   # calculation cannot proceed further\n    result.derive_impedance(series,Trt,freq,win_lim)\n\n    return result\n</code></pre>"},{"location":"api-pulseecho-simulations/","title":"Pulse-echo simulations","text":"<p>Pyintegrity facilitates reading simulated measurements from the public dataset Simulated ultrasonic pulse-echo well-integrity dataset by Diez, Viggen, and Johansen.</p>"},{"location":"api-pulseecho-simulations/#reading-from-the-dataset","title":"Reading from the dataset","text":""},{"location":"api-pulseecho-simulations/#pyintegrity.pulseecho.database.get_comsol_data","title":"<code>pyintegrity.pulseecho.database.get_comsol_data(filepath, filesIDs)</code>","text":"<p>read json files containing COMSOL model result creating a pandas dataframe containing a <code>PulseEchoSeries</code> and           model parameters related to the id of the file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>string to file path</p> required <code>filesIDs</code> <code>int | list</code> <p>either an integer, a range or a list to define the files that should be read, if a list with two  values is given, this is interpreted as a range</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas dataframe containing file name in the data base, PulseEchoSeries containing the data,             parameter class containing additional metedata from the model</p> Source code in <code>src/pyintegrity/pulseecho/database.py</code> <pre><code>def get_comsol_data(filepath: str,filesIDs: int | list):\n    \"\"\" read json files containing COMSOL model result creating a pandas dataframe containing a `PulseEchoSeries` and \\\n          model parameters related to the id of the file\n\n    Args:\n        filepath: string to file path\n        filesIDs: either an integer, a range or a list to define the files that should be read, if a list with two \n            values is given, this is interpreted as a range\n\n    Returns:\n        (DataFrame): pandas dataframe containing file name in the data base, PulseEchoSeries containing the data, \\\n            parameter class containing additional metedata from the model\n    \"\"\"\n    # Check if filesID is a range, a list or, a file\n    if isinstance(filesIDs, int):\n        fid=np.zeros([1],dtype=int)\n        fid[0]=filesIDs\n    elif len(filesIDs)==2:\n        fid=np.arange(filesIDs[0],filesIDs[1]+1)\n    else:\n        fid=np.array(filesIDs)\n    # headers for dataframe\n    headers=['fid','series','parameters'] \n    fid_series_meta=[]\n    # read the differetn files and append the data frame\n    for f in fid:\n        Jdata = _read_Database(filepath,f) \n        series = _to_PEseries(Jdata)\n        metadata = _get_metadata(Jdata)\n        fid_series_meta.append(pd.DataFrame([[f,series,metadata]], columns=headers))\n    return pd.concat(fid_series_meta, ignore_index=True)\n</code></pre>"},{"location":"api-pulseecho-simulations/#model-information-containers","title":"Model information containers","text":""},{"location":"api-pulseecho-simulations/#pyintegrity.model.Dims","title":"<code>pyintegrity.model.Dims</code>","text":"<p>Class to collect all the dimension information related to the Comsol model domain</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>float | None</code> <p>2.5D or 3D</p> <code>None</code> <code>geometry</code> <code>str | None</code> <p>plate or pipe</p> <code>None</code> <code>comsol_interface</code> <code>str | None</code> <p>time explicit or time domain</p> <code>None</code> <code>symmetries</code> <code>str | None</code> <p>axisymmetric, 2 symmetries, or 1 symmetry</p> <code>None</code> Source code in <code>src/pyintegrity/model.py</code> <pre><code>class Dims:\n    \"\"\" Class to collect all the dimension information related to the Comsol model domain\n\n    Args:\n        domain: 2.5D or 3D\n        geometry: plate or pipe\n        comsol_interface: time explicit or time domain\n        symmetries: axisymmetric, 2 symmetries, or 1 symmetry\n    \"\"\"\n    def __init__(self, \n                 domain: float | None = None,\n                 geometry: str | None = None,\n                 comsol_interface: str | None = None,\n                 symmetries: str | None = None) -&gt; None:\n        self.domain=domain\n        self.geometry=geometry\n        self.comsol_interface=comsol_interface\n        self.symmetries=symmetries\n</code></pre>"},{"location":"api-pulseecho-simulations/#pyintegrity.model.Eccentering","title":"<code>pyintegrity.model.Eccentering</code>","text":"<p>Class to collect all the information if a gap exists between the pipe and the outside material in the Comsol model </p> <p>Parameters:</p> Name Type Description Default <code>incident_angle</code> <code>float | Quantity | None</code> <p>incident angle on the pipe</p> required <code>transducer_pipe_distance</code> <code>float | Quantity | None</code> <p>actual transducer pipe distance in case of eccentering</p> required Source code in <code>src/pyintegrity/model.py</code> <pre><code>class Eccentering:\n    \"\"\" Class to collect all the information if a gap exists between the pipe\n    and the outside material in the Comsol model \n\n    Args:\n        incident_angle: incident angle on the pipe\n        transducer_pipe_distance: actual transducer pipe distance in case of eccentering\n    \"\"\"\n    def __init__(self,\n                 incident_angle: float | Quantity | None,\n                 transducer_pipe_distance: float | Quantity | None) -&gt; None:\n\n        if incident_angle is not None:\n            incident_angle = to_quantity(incident_angle, 'deg')\n        self.incident_angle=incident_angle\n\n        if transducer_pipe_distance is not None:\n            transducer_pipe_distance = to_quantity(transducer_pipe_distance, 'm')\n        self.transducer_pipe_distance=transducer_pipe_distance\n</code></pre>"},{"location":"api-pulseecho-simulations/#pyintegrity.model.Gap","title":"<code>pyintegrity.model.Gap</code>","text":"<p>Class to collect all the information if a gap exists between the pipe and the outside material in the Comsol model </p> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>Material | None</code> <p>Material class containing the parameters of the material in the gap</p> <code>None</code> <code>thickness</code> <code>float | Quantity | None</code> <p>thickness of the gap</p> <code>None</code> Source code in <code>src/pyintegrity/model.py</code> <pre><code>class Gap:\n    \"\"\" Class to collect all the information if a gap exists between the pipe\n    and the outside material in the Comsol model \n\n    Args:\n        material: Material class containing the parameters of the material in the gap\n        thickness: thickness of the gap\n    \"\"\"\n    def __init__(self,\n                 material: Material | None = None,\n                 thickness:  float | Quantity | None = None) -&gt; None:\n\n        self.material=material\n\n        if thickness is not None:\n            thickness = to_quantity(thickness, 'm')\n        self.thickness=thickness\n</code></pre>"},{"location":"api-pulseecho-simulations/#pyintegrity.model.Model","title":"<code>pyintegrity.model.Model</code>","text":"<p>Class to collect all the metadata from the subclasses</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Dims | None</code> <p>Dims class</p> <code>None</code> <code>transducer</code> <code>Transducer | None</code> <p>Transducer class</p> <code>None</code> <code>gap</code> <code>Gap | None</code> <p>Gap class</p> <code>None</code> <code>eccentering</code> <code>Eccentering | None</code> <p>Eccentering class</p> <code>None</code> <code>outside</code> <code>Material | None</code> <p>outside class</p> <code>None</code> Source code in <code>src/pyintegrity/model.py</code> <pre><code>class Model():\n    \"\"\" Class to collect all the metadata from the subclasses\n\n    Args:\n        dimensions: Dims class\n        transducer: Transducer class\n        gap: Gap class\n        eccentering: Eccentering class\n        outside: outside class\n    \"\"\"\n    def __init__(self, \n                dimensions: Dims | None = None,\n                transducer: Transducer | None = None,   # transducer, pulse, transducer pipe distance\n                gap: Gap | None = None,\n                eccentering: Eccentering | None = None,\n                outside: Material | None = None)-&gt; None:\n        self.dimensions=dimensions\n        self.transducer=transducer\n        self.gap=gap\n        self.eccentering=eccentering\n        self.outside=outside\n</code></pre>"},{"location":"api-pulseecho-simulations/#pyintegrity.model.Transducer","title":"<code>pyintegrity.model.Transducer</code>","text":"<p>Class to collect all the transducer information related to the Comsol model domain</p> <p>Parameters:</p> Name Type Description Default <code>diameter</code> <code>float | Quantity | None</code> <p>transducer diameter size</p> <code>None</code> <code>focal_length</code> <code>float | Quantity | None</code> <p>transducer focal length</p> <code>None</code> <code>apodization</code> <code>str | None</code> <p>apodization when sending the pulse</p> <code>None</code> <code>pulse_bw</code> <code>float | Quantity | None</code> <p>bandwidth of the pulse</p> <code>None</code> <code>pulse_max_t0</code> <code>float | Quantity | None</code> <p>time of maximum of the pulse</p> <code>None</code> <code>pulse_f0</code> <code>float | Quantity | None</code> <p>pulse frequency</p> <code>None</code> <code>transducer_pipe_distance</code> <code>float | Quantity | None</code> <p>distance between transducer center and pipe</p> <code>None</code> Source code in <code>src/pyintegrity/model.py</code> <pre><code>class Transducer:\n    \"\"\" Class to collect all the transducer information related to the Comsol model domain\n\n    Args:\n        diameter: transducer diameter size\n        focal_length: transducer focal length\n        apodization: apodization when sending the pulse\n        pulse_bw: bandwidth of the pulse\n        pulse_max_t0: time of maximum of the pulse\n        pulse_f0: pulse frequency\n        transducer_pipe_distance: distance between transducer center and pipe\n    \"\"\"\n    def __init__(self, \n                 diameter: float | Quantity | None = None,\n                 focal_length: float | Quantity | None = None,\n                 apodization: str | None = None,\n                 pulse_bw: float | Quantity | None = None,\n                 pulse_max_t0: float | Quantity | None = None,\n                 pulse_f0: float | Quantity | None = None,\n                 transducer_pipe_distance: float | Quantity | None = None) -&gt; None:\n\n        if diameter is not None:\n            diameter = to_quantity(diameter, 'm')\n        self.diameter=diameter\n\n        if focal_length is not None:\n            focal_length = to_quantity(focal_length, 'm')\n        self.focal_length=focal_length\n\n        self.apodization=apodization\n\n        self.pulse_bw=pulse_bw\n\n        if pulse_max_t0 is not None:\n            pulse_max_t0 = to_quantity(pulse_max_t0, 's')\n        self.pulse_max_t0=pulse_max_t0\n\n        if pulse_f0 is not None:\n            pulse_f0 = to_quantity(pulse_f0, 'Hz')\n        self.pulse_f0=pulse_f0\n\n        if transducer_pipe_distance is not None:\n            transducer_pipe_distance = to_quantity(transducer_pipe_distance, 'm')\n        self.transducer_pipe_distance=transducer_pipe_distance\n</code></pre>"}]}